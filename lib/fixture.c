/* fixture.c generated by valac 0.30.0, the Vala compiler
 * generated from fixture.vala, do not modify */

/*
 * Valadate - Unit testing library for GObject-based libraries.
 * Copyright (C) 2009  Jan Hudec <bulb@ucw.cz>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>


#define VALADATE_TYPE_FIXTURE (valadate_fixture_get_type ())
#define VALADATE_FIXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_TYPE_FIXTURE, ValadateFixture))
#define VALADATE_IS_FIXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_TYPE_FIXTURE))
#define VALADATE_FIXTURE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), VALADATE_TYPE_FIXTURE, ValadateFixtureIface))

typedef struct _ValadateFixture ValadateFixture;
typedef struct _ValadateFixtureIface ValadateFixtureIface;

struct _ValadateFixtureIface {
	GTypeInterface parent_iface;
	void (*set_up) (ValadateFixture* self);
	void (*tear_down) (ValadateFixture* self);
};



GType valadate_fixture_get_type (void) G_GNUC_CONST;
void valadate_fixture_set_up (ValadateFixture* self);
static void valadate_fixture_real_set_up (ValadateFixture* self);
void valadate_fixture_tear_down (ValadateFixture* self);
static void valadate_fixture_real_tear_down (ValadateFixture* self);
gint valadate_fixture_get_timeout (ValadateFixture* self);
void valadate_fixture_set_timeout (ValadateFixture* self, gint timeout);


/**
         * Called after construction before a test is run.
         *
         * You can use construct block (but not constructor) to the
         * same effect.
         */
static void valadate_fixture_real_set_up (ValadateFixture* self) {
}


void valadate_fixture_set_up (ValadateFixture* self) {
#line 75 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	g_return_if_fail (self != NULL);
#line 75 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	VALADATE_FIXTURE_GET_INTERFACE (self)->set_up (self);
#line 67 "fixture.c"
}


/**
         * Called after a test is run before the object is destroyed.
         *
         * You can use destructor to the same effect.
         */
static void valadate_fixture_real_tear_down (ValadateFixture* self) {
}


void valadate_fixture_tear_down (ValadateFixture* self) {
#line 82 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	g_return_if_fail (self != NULL);
#line 82 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	VALADATE_FIXTURE_GET_INTERFACE (self)->tear_down (self);
#line 85 "fixture.c"
}


/**
         * Timeout for async tests.
         *
         * You can change this in constructor or set_up to define the timeout
         * for async tests in this class. Value is in milliseconds and
         * default to 5000ms.
         *
         * This is a getter/setter pair rather than a property in order to work around this bug:
         * https://bugzilla.gnome.org/show_bug.cgi?id=624101
         */
gint valadate_fixture_get_timeout (ValadateFixture* self) {
	gint result = 0;
	gint v = 0;
	gconstpointer _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
#line 96 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	_tmp0_ = g_object_get_data ((GObject*) self, "Valadate.Fixture.timeout");
#line 96 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	v = (gint) ((glong) ((glong) ((gintptr) _tmp0_)));
#line 97 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	_tmp2_ = v;
#line 97 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	if (_tmp2_ == 0) {
#line 97 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
		_tmp1_ = 5000;
#line 115 "fixture.c"
	} else {
		gint _tmp3_ = 0;
#line 97 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
		_tmp3_ = v;
#line 97 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
		_tmp1_ = _tmp3_;
#line 122 "fixture.c"
	}
#line 97 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	result = _tmp1_;
#line 97 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	return result;
#line 128 "fixture.c"
}


void valadate_fixture_set_timeout (ValadateFixture* self, gint timeout) {
	gint _tmp0_ = 0;
	void* _tmp1_ = NULL;
#line 101 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	_tmp0_ = timeout;
#line 101 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	_tmp1_ = GINT_TO_POINTER (_tmp0_);
#line 101 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	g_object_set_data_full ((GObject*) self, "Valadate.Fixture.timeout", _tmp1_, NULL);
#line 141 "fixture.c"
}


static void valadate_fixture_base_init (ValadateFixtureIface * iface) {
#line 68 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	static gboolean initialized = FALSE;
#line 68 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
	if (!initialized) {
#line 68 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
		initialized = TRUE;
#line 68 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
		iface->set_up = valadate_fixture_real_set_up;
#line 68 "/home/bizarro/Documents/projects/valadate/lib/fixture.vala"
		iface->tear_down = valadate_fixture_real_tear_down;
#line 156 "fixture.c"
	}
}


/**
     * Marker interface for unit tests.
     *
     * To define a test suite, imlement this interface.
     * The runner will execute all methods whose names begin with "test_"
     * in that class, each on a separate instance.
     *
     * The set_up() method will be called before each test and
     * tear_down() will be called after. Since each test is run on
     * a separate instance, you can use construct block and destructor
     * with the same effect.
     *
     * [[warning:
     *   The constructor will ++not++ be called, because the object will
     *   be constructed using GLib.Object.newv. You have to use the
     *   //construct// block.
     * ]]
     *
     * Example:
     * {{{
     * class Test1 : Object, Valadate.Fixture {
     *     construct {
     *         stdout.printf ("Constructing fixture");
     *     }
     *     ~Test1 {
     *         stdout.printf ("Destroying fixture");
     *     }
     *     public void test_1 () {
     *         assert (0 != 1);
     *     }
     * }
     * }}}
     *
     * Test method declared async are also recognized and they are run under
     * main-loop until completion or timeout, which is taken from the
     * //timeout// property. Async test method can optionally have
     * a GLib.Cancellable argument, which will be cancelled when timeout
     * occurs.
     *
     * If you define some public constructible properties and for each
     * property define a static method named
     * "generate_"//property-name// returning a ValueArray, each test
     * will be called once for each value in the returned array. If you
     * define multiple property-generator pairs, the tests will be run
     * for each combination.
     */
GType valadate_fixture_get_type (void) {
	static volatile gsize valadate_fixture_type_id__volatile = 0;
	if (g_once_init_enter (&valadate_fixture_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadateFixtureIface), (GBaseInitFunc) valadate_fixture_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType valadate_fixture_type_id;
		valadate_fixture_type_id = g_type_register_static (G_TYPE_INTERFACE, "ValadateFixture", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (valadate_fixture_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&valadate_fixture_type_id__volatile, valadate_fixture_type_id);
	}
	return valadate_fixture_type_id__volatile;
}




/* prime.c generated by valac 0.30.0, the Vala compiler
 * generated from prime.vala, do not modify */

/*
 * Valadate - Unit testing library for GObject-based libraries.
 * Copyright (C) 2009  Jan Hudec <bulb@ucw.cz>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <libvaladate.h>


#define TEST_TYPE_TEST_PRIME (test_test_prime_get_type ())
#define TEST_TEST_PRIME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TEST_TYPE_TEST_PRIME, TestTestPrime))
#define TEST_TEST_PRIME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TEST_TYPE_TEST_PRIME, TestTestPrimeClass))
#define TEST_IS_TEST_PRIME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TEST_TYPE_TEST_PRIME))
#define TEST_IS_TEST_PRIME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TEST_TYPE_TEST_PRIME))
#define TEST_TEST_PRIME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TEST_TYPE_TEST_PRIME, TestTestPrimeClass))

typedef struct _TestTestPrime TestTestPrime;
typedef struct _TestTestPrimeClass TestTestPrimeClass;
typedef struct _TestTestPrimePrivate TestTestPrimePrivate;
#define _g_value_array_free0(var) ((var == NULL) ? NULL : (var = (g_value_array_free (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _TestTestPrime {
	GObject parent_instance;
	TestTestPrimePrivate * priv;
};

struct _TestTestPrimeClass {
	GObjectClass parent_class;
};

struct _TestTestPrimePrivate {
	gint _prime;
};


static gpointer test_test_prime_parent_class = NULL;
static ValadateFixtureIface* test_test_prime_valadate_fixture_parent_iface = NULL;

GType test_test_prime_get_type (void) G_GNUC_CONST;
#define TEST_TEST_PRIME_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TEST_TYPE_TEST_PRIME, TestTestPrimePrivate))
enum  {
	TEST_TEST_PRIME_DUMMY_PROPERTY,
	TEST_TEST_PRIME_PRIME
};
GValueArray* test_test_prime_generate_prime (void);
void test_test_prime_test_prime (TestTestPrime* self);
gint test_test_prime_get_prime (TestTestPrime* self);
TestTestPrime* test_test_prime_new (void);
TestTestPrime* test_test_prime_construct (GType object_type);
void test_test_prime_set_prime (TestTestPrime* self, gint value);
static void test_test_prime_finalize (GObject* obj);
static void _vala_test_test_prime_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_test_test_prime_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


GValueArray* test_test_prime_generate_prime (void) {
	GValueArray* result = NULL;
	GValueArray* ret = NULL;
	GValueArray* _tmp0_ = NULL;
	GValue _tmp1_ = {0};
	GValue _tmp2_ = {0};
	GValue _tmp3_ = {0};
	GValue _tmp4_ = {0};
	GValue _tmp5_ = {0};
	GValue _tmp6_ = {0};
	GValue _tmp7_ = {0};
	GValue _tmp8_ = {0};
	_tmp0_ = g_value_array_new ((guint) 8);
	ret = _tmp0_;
	g_value_init (&_tmp1_, G_TYPE_INT);
	g_value_set_int (&_tmp1_, 3);
	g_value_array_append (ret, &_tmp1_);
	G_IS_VALUE (&_tmp1_) ? (g_value_unset (&_tmp1_), NULL) : NULL;
	g_value_init (&_tmp2_, G_TYPE_INT);
	g_value_set_int (&_tmp2_, 5);
	g_value_array_append (ret, &_tmp2_);
	G_IS_VALUE (&_tmp2_) ? (g_value_unset (&_tmp2_), NULL) : NULL;
	g_value_init (&_tmp3_, G_TYPE_INT);
	g_value_set_int (&_tmp3_, 7);
	g_value_array_append (ret, &_tmp3_);
	G_IS_VALUE (&_tmp3_) ? (g_value_unset (&_tmp3_), NULL) : NULL;
	g_value_init (&_tmp4_, G_TYPE_INT);
	g_value_set_int (&_tmp4_, 11);
	g_value_array_append (ret, &_tmp4_);
	G_IS_VALUE (&_tmp4_) ? (g_value_unset (&_tmp4_), NULL) : NULL;
	g_value_init (&_tmp5_, G_TYPE_INT);
	g_value_set_int (&_tmp5_, 13);
	g_value_array_append (ret, &_tmp5_);
	G_IS_VALUE (&_tmp5_) ? (g_value_unset (&_tmp5_), NULL) : NULL;
	g_value_init (&_tmp6_, G_TYPE_INT);
	g_value_set_int (&_tmp6_, 17);
	g_value_array_append (ret, &_tmp6_);
	G_IS_VALUE (&_tmp6_) ? (g_value_unset (&_tmp6_), NULL) : NULL;
	g_value_init (&_tmp7_, G_TYPE_INT);
	g_value_set_int (&_tmp7_, 19);
	g_value_array_append (ret, &_tmp7_);
	G_IS_VALUE (&_tmp7_) ? (g_value_unset (&_tmp7_), NULL) : NULL;
	g_value_init (&_tmp8_, G_TYPE_INT);
	g_value_set_int (&_tmp8_, 23);
	g_value_array_append (ret, &_tmp8_);
	G_IS_VALUE (&_tmp8_) ? (g_value_unset (&_tmp8_), NULL) : NULL;
	result = ret;
	return result;
}


void test_test_prime_test_prime (TestTestPrime* self) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_prime;
	_vala_assert (_tmp0_ > 1, "prime > 1");
	{
		gint i = 0;
		i = 2;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gint _tmp3_ = 0;
				gint _tmp4_ = 0;
				gint _tmp5_ = 0;
				gint _tmp6_ = 0;
				gint _tmp7_ = 0;
				if (!_tmp1_) {
					gint _tmp2_ = 0;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = self->priv->_prime;
				_tmp4_ = i;
				_tmp5_ = i;
				if (!((_tmp3_ / _tmp4_) >= _tmp5_)) {
					break;
				}
				_tmp6_ = self->priv->_prime;
				_tmp7_ = i;
				_vala_assert ((_tmp6_ % _tmp7_) != 0, "prime % i != 0");
			}
		}
	}
}


TestTestPrime* test_test_prime_construct (GType object_type) {
	TestTestPrime * self = NULL;
	self = (TestTestPrime*) g_object_new (object_type, NULL);
	return self;
}


TestTestPrime* test_test_prime_new (void) {
	return test_test_prime_construct (TEST_TYPE_TEST_PRIME);
}


gint test_test_prime_get_prime (TestTestPrime* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_prime;
	result = _tmp0_;
	return result;
}


void test_test_prime_set_prime (TestTestPrime* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_prime = _tmp0_;
	g_object_notify ((GObject *) self, "prime");
}


static void test_test_prime_class_init (TestTestPrimeClass * klass) {
	test_test_prime_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TestTestPrimePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_test_test_prime_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_test_test_prime_set_property;
	G_OBJECT_CLASS (klass)->finalize = test_test_prime_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), TEST_TEST_PRIME_PRIME, g_param_spec_int ("prime", "prime", "prime", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void test_test_prime_valadate_fixture_interface_init (ValadateFixtureIface * iface) {
	test_test_prime_valadate_fixture_parent_iface = g_type_interface_peek_parent (iface);
}


static void test_test_prime_instance_init (TestTestPrime * self) {
	self->priv = TEST_TEST_PRIME_GET_PRIVATE (self);
}


static void test_test_prime_finalize (GObject* obj) {
	TestTestPrime * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TEST_TYPE_TEST_PRIME, TestTestPrime);
	G_OBJECT_CLASS (test_test_prime_parent_class)->finalize (obj);
}


GType test_test_prime_get_type (void) {
	static volatile gsize test_test_prime_type_id__volatile = 0;
	if (g_once_init_enter (&test_test_prime_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TestTestPrimeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) test_test_prime_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TestTestPrime), 0, (GInstanceInitFunc) test_test_prime_instance_init, NULL };
		static const GInterfaceInfo valadate_fixture_info = { (GInterfaceInitFunc) test_test_prime_valadate_fixture_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType test_test_prime_type_id;
		test_test_prime_type_id = g_type_register_static (G_TYPE_OBJECT, "TestTestPrime", &g_define_type_info, 0);
		g_type_add_interface_static (test_test_prime_type_id, VALADATE_TYPE_FIXTURE, &valadate_fixture_info);
		g_once_init_leave (&test_test_prime_type_id__volatile, test_test_prime_type_id);
	}
	return test_test_prime_type_id__volatile;
}


static void _vala_test_test_prime_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	TestTestPrime * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TEST_TYPE_TEST_PRIME, TestTestPrime);
	switch (property_id) {
		case TEST_TEST_PRIME_PRIME:
		g_value_set_int (value, test_test_prime_get_prime (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_test_test_prime_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	TestTestPrime * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TEST_TYPE_TEST_PRIME, TestTestPrime);
	switch (property_id) {
		case TEST_TEST_PRIME_PRIME:
		test_test_prime_set_prime (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




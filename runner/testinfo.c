/* testinfo.c generated by valac 0.30.0, the Vala compiler
 * generated from testinfo.vala, do not modify */

/*
 * Valadate - Unit testing library for GObject-based libraries.
 * Copyright (C) 2009  Jan Hudec <bulb@ucw.cz>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include "libvaladate.h"
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define VALADATE_RUNNER_TYPE_FIXTURE_POINTER (valadate_runner_fixture_pointer_get_type ())
typedef struct _ValadateRunnerFixturePointer ValadateRunnerFixturePointer;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define VALADATE_RUNNER_TYPE_TEST_INFO (valadate_runner_test_info_get_type ())
#define VALADATE_RUNNER_TEST_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_TEST_INFO, ValadateRunnerTestInfo))
#define VALADATE_RUNNER_TEST_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADATE_RUNNER_TYPE_TEST_INFO, ValadateRunnerTestInfoClass))
#define VALADATE_RUNNER_IS_TEST_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_TEST_INFO))
#define VALADATE_RUNNER_IS_TEST_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADATE_RUNNER_TYPE_TEST_INFO))
#define VALADATE_RUNNER_TEST_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADATE_RUNNER_TYPE_TEST_INFO, ValadateRunnerTestInfoClass))

typedef struct _ValadateRunnerTestInfo ValadateRunnerTestInfo;
typedef struct _ValadateRunnerTestInfoClass ValadateRunnerTestInfoClass;
typedef struct _ValadateRunnerTestInfoPrivate ValadateRunnerTestInfoPrivate;
typedef struct _ValadateRunnerParamSpecTestInfo ValadateRunnerParamSpecTestInfo;
typedef struct _Block1Data Block1Data;
typedef struct _Block2Data Block2Data;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

typedef void (*ValadateRunnerTestMarshaller) (ValadateFixture* fixture, void* arg1, void* arg2, void* user_data);
struct _ValadateRunnerFixturePointer {
	ValadateFixture* fixture;
};

struct _ValadateRunnerTestInfo {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValadateRunnerTestInfoPrivate * priv;
};

struct _ValadateRunnerTestInfoClass {
	GTypeClass parent_class;
	void (*finalize) (ValadateRunnerTestInfo *self);
};

struct _ValadateRunnerTestInfoPrivate {
	GType type;
	ValadateRunnerTestMarshaller marshaller;
	gpointer marshaller_target;
	GDestroyNotify marshaller_target_destroy_notify;
	void* arg1;
	void* arg2;
	GParameter* parameters;
	gint parameters_length1;
	gint _parameters_size_;
};

struct _ValadateRunnerParamSpecTestInfo {
	GParamSpec parent_instance;
};

typedef void (*ValadateRunnerTestMethodSync) (ValadateFixture* fx, void* user_data);
typedef void (*ValadateRunnerTestMethodAsync) (ValadateFixture* fx, GAsyncReadyCallback callback, void* callback_target, void* user_data);
typedef void (*ValadateRunnerTestMethodCancellable) (ValadateFixture* fx, GCancellable* cancel, GAsyncReadyCallback callback, void* callback_target, void* user_data);
typedef void (*ValadateRunnerTestMethodFinish) (ValadateFixture* fx, GAsyncResult* _result_, void* user_data);
struct _Block1Data {
	int _ref_count_;
	ValadateFixture* it;
	void* arg1;
	void* arg2;
};

struct _Block2Data {
	int _ref_count_;
	ValadateFixture* it;
	void* arg1;
	void* arg2;
};


static gpointer valadate_runner_test_info_parent_class = NULL;

GType valadate_runner_fixture_pointer_get_type (void) G_GNUC_CONST;
ValadateRunnerFixturePointer* valadate_runner_fixture_pointer_dup (const ValadateRunnerFixturePointer* self);
void valadate_runner_fixture_pointer_free (ValadateRunnerFixturePointer* self);
void valadate_runner_fixture_pointer_copy (const ValadateRunnerFixturePointer* self, ValadateRunnerFixturePointer* dest);
void valadate_runner_fixture_pointer_destroy (ValadateRunnerFixturePointer* self);
gpointer valadate_runner_test_info_ref (gpointer instance);
void valadate_runner_test_info_unref (gpointer instance);
GParamSpec* valadate_runner_param_spec_test_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void valadate_runner_value_set_test_info (GValue* value, gpointer v_object);
void valadate_runner_value_take_test_info (GValue* value, gpointer v_object);
gpointer valadate_runner_value_get_test_info (const GValue* value);
GType valadate_runner_test_info_get_type (void) G_GNUC_CONST;
#define VALADATE_RUNNER_TEST_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALADATE_RUNNER_TYPE_TEST_INFO, ValadateRunnerTestInfoPrivate))
enum  {
	VALADATE_RUNNER_TEST_INFO_DUMMY_PROPERTY
};
static void g_parameter_destroy (GParameter* self);
static void _vala_GParameter_array_free (GParameter* array, gint array_length);
ValadateRunnerTestInfo* valadate_runner_test_info_new (GType type, ValadateRunnerTestMarshaller marshaller, void* marshaller_target, void* arg1, void* arg2, GParameter* parameters, int parameters_length1);
ValadateRunnerTestInfo* valadate_runner_test_info_construct (GType object_type, GType type, ValadateRunnerTestMarshaller marshaller, void* marshaller_target, void* arg1, void* arg2, GParameter* parameters, int parameters_length1);
static void g_parameter_copy (const GParameter* self, GParameter* dest);
static GParameter* _vala_array_dup3 (GParameter* self, int length);
GTestCase* valadate_runner_test_info_make_case (ValadateRunnerTestInfo* self, const gchar* name);
static void valadate_runner_test_info_set_up (ValadateRunnerTestInfo* self, void* data);
static void _valadate_runner_test_info_set_up_gtest_fixture_func (void* fixture, gpointer self);
static void valadate_runner_test_info_run (ValadateRunnerTestInfo* self, void* data);
static void _valadate_runner_test_info_run_gtest_fixture_func (void* fixture, gpointer self);
static void valadate_runner_test_info_tear_down (ValadateRunnerTestInfo* self, void* data);
static void _valadate_runner_test_info_tear_down_gtest_fixture_func (void* fixture, gpointer self);
static void valadate_runner_test_info_finalize (ValadateRunnerTestInfo* obj);
void valadate_runner_test_marshal_synchronous (ValadateFixture* it, void* arg1, void* arg2);
void valadate_runner_test_marshal_asynchronous (ValadateFixture* it, void* arg1, void* arg2);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda4_ (Block1Data* _data1_, GAsyncReadyCallback cb, void* cb_target);
static void ___lambda4__valadate_async_begin (GAsyncReadyCallback callback, void* callback_target, gpointer self);
static void __lambda5_ (Block1Data* _data1_, GAsyncResult* r);
static void ___lambda5__valadate_async_finish (GAsyncResult* _result_, gpointer self);
void valadate_runner_test_marshal_cancellable (ValadateFixture* it, void* arg1, void* arg2);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void __lambda6_ (Block2Data* _data2_, GCancellable* c, GAsyncReadyCallback cb, void* cb_target);
static void ___lambda6__valadate_cancelable_async_begin (GCancellable* cancel, GAsyncReadyCallback callback, void* callback_target, gpointer self);
static void __lambda7_ (Block2Data* _data2_, GAsyncResult* r);
static void ___lambda7__valadate_async_finish (GAsyncResult* _result_, gpointer self);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void valadate_runner_fixture_pointer_copy (const ValadateRunnerFixturePointer* self, ValadateRunnerFixturePointer* dest) {
	ValadateFixture* _tmp0_ = NULL;
	ValadateFixture* _tmp1_ = NULL;
	_tmp0_ = (*self).fixture;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 ((*dest).fixture);
	(*dest).fixture = _tmp1_;
}


void valadate_runner_fixture_pointer_destroy (ValadateRunnerFixturePointer* self) {
	_g_object_unref0 ((*self).fixture);
}


ValadateRunnerFixturePointer* valadate_runner_fixture_pointer_dup (const ValadateRunnerFixturePointer* self) {
	ValadateRunnerFixturePointer* dup;
	dup = g_new0 (ValadateRunnerFixturePointer, 1);
	valadate_runner_fixture_pointer_copy (self, dup);
	return dup;
}


void valadate_runner_fixture_pointer_free (ValadateRunnerFixturePointer* self) {
	valadate_runner_fixture_pointer_destroy (self);
	g_free (self);
}


GType valadate_runner_fixture_pointer_get_type (void) {
	static volatile gsize valadate_runner_fixture_pointer_type_id__volatile = 0;
	if (g_once_init_enter (&valadate_runner_fixture_pointer_type_id__volatile)) {
		GType valadate_runner_fixture_pointer_type_id;
		valadate_runner_fixture_pointer_type_id = g_boxed_type_register_static ("ValadateRunnerFixturePointer", (GBoxedCopyFunc) valadate_runner_fixture_pointer_dup, (GBoxedFreeFunc) valadate_runner_fixture_pointer_free);
		g_once_init_leave (&valadate_runner_fixture_pointer_type_id__volatile, valadate_runner_fixture_pointer_type_id);
	}
	return valadate_runner_fixture_pointer_type_id__volatile;
}


static void g_parameter_destroy (GParameter* self) {
	G_IS_VALUE (&(*self).value) ? (g_value_unset (&(*self).value), NULL) : NULL;
}


static void _vala_GParameter_array_free (GParameter* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			g_parameter_destroy (&array[i]);
		}
	}
	g_free (array);
}


static void g_parameter_copy (const GParameter* self, GParameter* dest) {
	const gchar* _tmp0_ = NULL;
	GValue _tmp1_ = {0};
	GValue _tmp2_ = {0};
	_tmp0_ = (*self).name;
	(*dest).name = _tmp0_;
	_tmp1_ = (*self).value;
	if (G_IS_VALUE (&_tmp1_)) {
		g_value_init (&_tmp2_, G_VALUE_TYPE (&_tmp1_));
		g_value_copy (&_tmp1_, &_tmp2_);
	} else {
		_tmp2_ = _tmp1_;
	}
	G_IS_VALUE (&(*dest).value) ? (g_value_unset (&(*dest).value), NULL) : NULL;
	(*dest).value = _tmp2_;
}


static GParameter* _vala_array_dup3 (GParameter* self, int length) {
	GParameter* result;
	int i;
	result = g_new0 (GParameter, length);
	for (i = 0; i < length; i++) {
		GParameter _tmp0_ = {0};
		g_parameter_copy (&self[i], &_tmp0_);
		result[i] = _tmp0_;
	}
	return result;
}


ValadateRunnerTestInfo* valadate_runner_test_info_construct (GType object_type, GType type, ValadateRunnerTestMarshaller marshaller, void* marshaller_target, void* arg1, void* arg2, GParameter* parameters, int parameters_length1) {
	ValadateRunnerTestInfo* self = NULL;
	GType _tmp0_ = 0UL;
	ValadateRunnerTestMarshaller _tmp1_ = NULL;
	void* _tmp1__target = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	GParameter* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	GParameter* _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	self = (ValadateRunnerTestInfo*) g_type_create_instance (object_type);
	_tmp0_ = type;
	self->priv->type = _tmp0_;
	_tmp1_ = marshaller;
	_tmp1__target = marshaller_target;
	(self->priv->marshaller_target_destroy_notify == NULL) ? NULL : (self->priv->marshaller_target_destroy_notify (self->priv->marshaller_target), NULL);
	self->priv->marshaller = NULL;
	self->priv->marshaller_target = NULL;
	self->priv->marshaller_target_destroy_notify = NULL;
	self->priv->marshaller = _tmp1_;
	self->priv->marshaller_target = _tmp1__target;
	self->priv->marshaller_target_destroy_notify = NULL;
	_tmp2_ = arg1;
	self->priv->arg1 = _tmp2_;
	_tmp3_ = arg2;
	self->priv->arg2 = _tmp3_;
	_tmp4_ = parameters;
	_tmp4__length1 = parameters_length1;
	_tmp5_ = (_tmp4_ != NULL) ? _vala_array_dup3 (_tmp4_, _tmp4__length1) : ((gpointer) _tmp4_);
	_tmp5__length1 = _tmp4__length1;
	self->priv->parameters = (_vala_GParameter_array_free (self->priv->parameters, self->priv->parameters_length1), NULL);
	self->priv->parameters = _tmp5_;
	self->priv->parameters_length1 = _tmp5__length1;
	self->priv->_parameters_size_ = self->priv->parameters_length1;
	parameters = (_vala_GParameter_array_free (parameters, parameters_length1), NULL);
	return self;
}


ValadateRunnerTestInfo* valadate_runner_test_info_new (GType type, ValadateRunnerTestMarshaller marshaller, void* marshaller_target, void* arg1, void* arg2, GParameter* parameters, int parameters_length1) {
	return valadate_runner_test_info_construct (VALADATE_RUNNER_TYPE_TEST_INFO, type, marshaller, marshaller_target, arg1, arg2, parameters, parameters_length1);
}


static void _valadate_runner_test_info_set_up_gtest_fixture_func (void* fixture, gpointer self) {
	valadate_runner_test_info_set_up ((ValadateRunnerTestInfo*) self, fixture);
}


static void _valadate_runner_test_info_run_gtest_fixture_func (void* fixture, gpointer self) {
	valadate_runner_test_info_run ((ValadateRunnerTestInfo*) self, fixture);
}


static void _valadate_runner_test_info_tear_down_gtest_fixture_func (void* fixture, gpointer self) {
	valadate_runner_test_info_tear_down ((ValadateRunnerTestInfo*) self, fixture);
}


GTestCase* valadate_runner_test_info_make_case (ValadateRunnerTestInfo* self, const gchar* name) {
	GTestCase* result = NULL;
	const gchar* _tmp0_ = NULL;
	GTestCase* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = name;
	_tmp1_ = g_test_create_case (_tmp0_, (gsize) sizeof (ValadateRunnerFixturePointer), self, _valadate_runner_test_info_set_up_gtest_fixture_func, _valadate_runner_test_info_run_gtest_fixture_func, _valadate_runner_test_info_tear_down_gtest_fixture_func);
	result = _tmp1_;
	return result;
}


static void valadate_runner_test_info_set_up (ValadateRunnerTestInfo* self, void* data) {
	ValadateRunnerFixturePointer* fp = NULL;
	void* _tmp0_ = NULL;
	GType _tmp1_ = 0UL;
	GParameter* _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	GObject* _tmp3_ = NULL;
	GObject* _tmp4_ = NULL;
	ValadateFixture* _tmp5_ = NULL;
	ValadateFixture* _tmp6_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = data;
	fp = _tmp0_;
	_tmp1_ = self->priv->type;
	_tmp2_ = self->priv->parameters;
	_tmp2__length1 = self->priv->parameters_length1;
	_tmp3_ = g_object_newv (_tmp1_, _tmp2__length1, _tmp2_);
	_tmp4_ = G_IS_INITIALLY_UNOWNED (_tmp3_) ? g_object_ref_sink (_tmp3_) : _tmp3_;
	_tmp5_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, VALADATE_TYPE_FIXTURE) ? ((ValadateFixture*) _tmp4_) : NULL;
	if (_tmp5_ == NULL) {
		_g_object_unref0 (_tmp4_);
	}
	_g_object_unref0 ((*fp).fixture);
	(*fp).fixture = _tmp5_;
	_tmp6_ = (*fp).fixture;
	valadate_fixture_set_up (_tmp6_);
}


static void valadate_runner_test_info_tear_down (ValadateRunnerTestInfo* self, void* data) {
	ValadateRunnerFixturePointer* fp = NULL;
	void* _tmp0_ = NULL;
	ValadateFixture* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = data;
	fp = _tmp0_;
	_tmp1_ = (*fp).fixture;
	valadate_fixture_tear_down (_tmp1_);
	_g_object_unref0 ((*fp).fixture);
	(*fp).fixture = NULL;
}


static void valadate_runner_test_info_run (ValadateRunnerTestInfo* self, void* data) {
	ValadateRunnerFixturePointer* fp = NULL;
	void* _tmp0_ = NULL;
	ValadateRunnerTestMarshaller _tmp1_ = NULL;
	void* _tmp1__target = NULL;
	ValadateFixture* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = data;
	fp = _tmp0_;
	_tmp1_ = self->priv->marshaller;
	_tmp1__target = self->priv->marshaller_target;
	_tmp2_ = (*fp).fixture;
	_tmp3_ = self->priv->arg1;
	_tmp4_ = self->priv->arg2;
	_tmp1_ (_tmp2_, _tmp3_, _tmp4_, _tmp1__target);
}


static void valadate_runner_value_test_info_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void valadate_runner_value_test_info_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		valadate_runner_test_info_unref (value->data[0].v_pointer);
	}
}


static void valadate_runner_value_test_info_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = valadate_runner_test_info_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer valadate_runner_value_test_info_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* valadate_runner_value_test_info_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ValadateRunnerTestInfo* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = valadate_runner_test_info_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* valadate_runner_value_test_info_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ValadateRunnerTestInfo** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = valadate_runner_test_info_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* valadate_runner_param_spec_test_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ValadateRunnerParamSpecTestInfo* spec;
	g_return_val_if_fail (g_type_is_a (object_type, VALADATE_RUNNER_TYPE_TEST_INFO), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer valadate_runner_value_get_test_info (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALADATE_RUNNER_TYPE_TEST_INFO), NULL);
	return value->data[0].v_pointer;
}


void valadate_runner_value_set_test_info (GValue* value, gpointer v_object) {
	ValadateRunnerTestInfo* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALADATE_RUNNER_TYPE_TEST_INFO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALADATE_RUNNER_TYPE_TEST_INFO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		valadate_runner_test_info_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		valadate_runner_test_info_unref (old);
	}
}


void valadate_runner_value_take_test_info (GValue* value, gpointer v_object) {
	ValadateRunnerTestInfo* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALADATE_RUNNER_TYPE_TEST_INFO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALADATE_RUNNER_TYPE_TEST_INFO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		valadate_runner_test_info_unref (old);
	}
}


static void valadate_runner_test_info_class_init (ValadateRunnerTestInfoClass * klass) {
	valadate_runner_test_info_parent_class = g_type_class_peek_parent (klass);
	((ValadateRunnerTestInfoClass *) klass)->finalize = valadate_runner_test_info_finalize;
	g_type_class_add_private (klass, sizeof (ValadateRunnerTestInfoPrivate));
}


static void valadate_runner_test_info_instance_init (ValadateRunnerTestInfo * self) {
	self->priv = VALADATE_RUNNER_TEST_INFO_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void valadate_runner_test_info_finalize (ValadateRunnerTestInfo* obj) {
	ValadateRunnerTestInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADATE_RUNNER_TYPE_TEST_INFO, ValadateRunnerTestInfo);
	g_signal_handlers_destroy (self);
	(self->priv->marshaller_target_destroy_notify == NULL) ? NULL : (self->priv->marshaller_target_destroy_notify (self->priv->marshaller_target), NULL);
	self->priv->marshaller = NULL;
	self->priv->marshaller_target = NULL;
	self->priv->marshaller_target_destroy_notify = NULL;
	self->priv->parameters = (_vala_GParameter_array_free (self->priv->parameters, self->priv->parameters_length1), NULL);
}


GType valadate_runner_test_info_get_type (void) {
	static volatile gsize valadate_runner_test_info_type_id__volatile = 0;
	if (g_once_init_enter (&valadate_runner_test_info_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { valadate_runner_value_test_info_init, valadate_runner_value_test_info_free_value, valadate_runner_value_test_info_copy_value, valadate_runner_value_test_info_peek_pointer, "p", valadate_runner_value_test_info_collect_value, "p", valadate_runner_value_test_info_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ValadateRunnerTestInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadate_runner_test_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadateRunnerTestInfo), 0, (GInstanceInitFunc) valadate_runner_test_info_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType valadate_runner_test_info_type_id;
		valadate_runner_test_info_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ValadateRunnerTestInfo", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&valadate_runner_test_info_type_id__volatile, valadate_runner_test_info_type_id);
	}
	return valadate_runner_test_info_type_id__volatile;
}


gpointer valadate_runner_test_info_ref (gpointer instance) {
	ValadateRunnerTestInfo* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void valadate_runner_test_info_unref (gpointer instance) {
	ValadateRunnerTestInfo* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		VALADATE_RUNNER_TEST_INFO_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


void valadate_runner_test_marshal_synchronous (ValadateFixture* it, void* arg1, void* arg2) {
	void* _tmp0_ = NULL;
	ValadateFixture* _tmp1_ = NULL;
	g_return_if_fail (it != NULL);
	_tmp0_ = arg1;
	_tmp1_ = it;
	((ValadateRunnerTestMethodSync) _tmp0_) (_tmp1_, NULL);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->it);
		g_slice_free (Block1Data, _data1_);
	}
}


static void __lambda4_ (Block1Data* _data1_, GAsyncReadyCallback cb, void* cb_target) {
	void* _tmp0_ = NULL;
	ValadateFixture* _tmp1_ = NULL;
	GAsyncReadyCallback _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	_tmp0_ = _data1_->arg1;
	_tmp1_ = _data1_->it;
	_tmp2_ = cb;
	_tmp2__target = cb_target;
	((ValadateRunnerTestMethodAsync) _tmp0_) (_tmp1_, _tmp2_, _tmp2__target, NULL);
}


static void ___lambda4__valadate_async_begin (GAsyncReadyCallback callback, void* callback_target, gpointer self) {
	__lambda4_ (self, callback, callback_target);
}


static void __lambda5_ (Block1Data* _data1_, GAsyncResult* r) {
	void* _tmp0_ = NULL;
	ValadateFixture* _tmp1_ = NULL;
	GAsyncResult* _tmp2_ = NULL;
	g_return_if_fail (r != NULL);
	_tmp0_ = _data1_->arg2;
	_tmp1_ = _data1_->it;
	_tmp2_ = r;
	((ValadateRunnerTestMethodFinish) _tmp0_) (_tmp1_, _tmp2_, NULL);
}


static void ___lambda5__valadate_async_finish (GAsyncResult* _result_, gpointer self) {
	__lambda5_ (self, _result_);
}


void valadate_runner_test_marshal_asynchronous (ValadateFixture* it, void* arg1, void* arg2) {
	Block1Data* _data1_;
	ValadateFixture* _tmp0_ = NULL;
	ValadateFixture* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	ValadateFixture* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (it != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_tmp0_ = it;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data1_->it);
	_data1_->it = _tmp1_;
	_tmp2_ = arg1;
	_data1_->arg1 = _tmp2_;
	_tmp3_ = arg2;
	_data1_->arg2 = _tmp3_;
	_tmp4_ = _data1_->it;
	_tmp5_ = valadate_fixture_get_timeout (_tmp4_);
	_tmp6_ = valadate_wait_for_async (_tmp5_, ___lambda4__valadate_async_begin, _data1_, ___lambda5__valadate_async_finish, _data1_);
	_vala_assert (_tmp6_, "Valadate.wait_for_async(it.get_timeout(),                     (cb) => ((TestMethodAsync)arg1)(it, cb),                     (r) => ((TestMethodFinish)arg2)(it, r))");
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_object_unref0 (_data2_->it);
		g_slice_free (Block2Data, _data2_);
	}
}


static void __lambda6_ (Block2Data* _data2_, GCancellable* c, GAsyncReadyCallback cb, void* cb_target) {
	void* _tmp0_ = NULL;
	ValadateFixture* _tmp1_ = NULL;
	GCancellable* _tmp2_ = NULL;
	GAsyncReadyCallback _tmp3_ = NULL;
	void* _tmp3__target = NULL;
	g_return_if_fail (c != NULL);
	_tmp0_ = _data2_->arg1;
	_tmp1_ = _data2_->it;
	_tmp2_ = c;
	_tmp3_ = cb;
	_tmp3__target = cb_target;
	((ValadateRunnerTestMethodCancellable) _tmp0_) (_tmp1_, _tmp2_, _tmp3_, _tmp3__target, NULL);
}


static void ___lambda6__valadate_cancelable_async_begin (GCancellable* cancel, GAsyncReadyCallback callback, void* callback_target, gpointer self) {
	__lambda6_ (self, cancel, callback, callback_target);
}


static void __lambda7_ (Block2Data* _data2_, GAsyncResult* r) {
	void* _tmp0_ = NULL;
	ValadateFixture* _tmp1_ = NULL;
	GAsyncResult* _tmp2_ = NULL;
	g_return_if_fail (r != NULL);
	_tmp0_ = _data2_->arg2;
	_tmp1_ = _data2_->it;
	_tmp2_ = r;
	((ValadateRunnerTestMethodFinish) _tmp0_) (_tmp1_, _tmp2_, NULL);
}


static void ___lambda7__valadate_async_finish (GAsyncResult* _result_, gpointer self) {
	__lambda7_ (self, _result_);
}


void valadate_runner_test_marshal_cancellable (ValadateFixture* it, void* arg1, void* arg2) {
	Block2Data* _data2_;
	ValadateFixture* _tmp0_ = NULL;
	ValadateFixture* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	ValadateFixture* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (it != NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_tmp0_ = it;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data2_->it);
	_data2_->it = _tmp1_;
	_tmp2_ = arg1;
	_data2_->arg1 = _tmp2_;
	_tmp3_ = arg2;
	_data2_->arg2 = _tmp3_;
	_tmp4_ = _data2_->it;
	_tmp5_ = valadate_fixture_get_timeout (_tmp4_);
	_tmp6_ = valadate_wait_for_cancellable_async (_tmp5_, ___lambda6__valadate_cancelable_async_begin, _data2_, ___lambda7__valadate_async_finish, _data2_);
	_vala_assert (_tmp6_, "Valadate.wait_for_cancellable_async(it.get_timeout(),                     (c, cb) => ((TestMethodCancellable)arg1)(it, c, cb),                     (r) => ((TestMethodFinish)arg2)(it, r))");
	block2_data_unref (_data2_);
	_data2_ = NULL;
}




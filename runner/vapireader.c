/* vapireader.c generated by valac 0.30.0, the Vala compiler
 * generated from vapireader.vala, do not modify */

/*
 * Valadate - Unit testing library for GObject-based libraries.
 * Copyright (C) 2009  Jan Hudec <bulb@ucw.cz>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <vala.h>
#include <stdio.h>
#include <glib/gstdio.h>


#define VALADATE_RUNNER_TYPE_READER (valadate_runner_reader_get_type ())
#define VALADATE_RUNNER_READER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_READER, ValadateRunnerReader))
#define VALADATE_RUNNER_IS_READER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_READER))
#define VALADATE_RUNNER_READER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), VALADATE_RUNNER_TYPE_READER, ValadateRunnerReaderIface))

typedef struct _ValadateRunnerReader ValadateRunnerReader;
typedef struct _ValadateRunnerReaderIface ValadateRunnerReaderIface;

#define VALADATE_RUNNER_TYPE_VAPI_READER (valadate_runner_vapi_reader_get_type ())
#define VALADATE_RUNNER_VAPI_READER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_VAPI_READER, ValadateRunnerVapiReader))
#define VALADATE_RUNNER_VAPI_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADATE_RUNNER_TYPE_VAPI_READER, ValadateRunnerVapiReaderClass))
#define VALADATE_RUNNER_IS_VAPI_READER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_VAPI_READER))
#define VALADATE_RUNNER_IS_VAPI_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADATE_RUNNER_TYPE_VAPI_READER))
#define VALADATE_RUNNER_VAPI_READER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADATE_RUNNER_TYPE_VAPI_READER, ValadateRunnerVapiReaderClass))

typedef struct _ValadateRunnerVapiReader ValadateRunnerVapiReader;
typedef struct _ValadateRunnerVapiReaderClass ValadateRunnerVapiReaderClass;
typedef struct _ValadateRunnerVapiReaderPrivate ValadateRunnerVapiReaderPrivate;
#define _vala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_context_unref (var), NULL)))
#define _vala_source_file_unref0(var) ((var == NULL) ? NULL : (var = (vala_source_file_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_code_visitor_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_visitor_unref (var), NULL)))

#define VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER (valadate_runner_vapi_test_gatherer_get_type ())
#define VALADATE_RUNNER_VAPI_TEST_GATHERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER, ValadateRunnerVapiTestGatherer))
#define VALADATE_RUNNER_VAPI_TEST_GATHERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER, ValadateRunnerVapiTestGathererClass))
#define VALADATE_RUNNER_IS_VAPI_TEST_GATHERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER))
#define VALADATE_RUNNER_IS_VAPI_TEST_GATHERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER))
#define VALADATE_RUNNER_VAPI_TEST_GATHERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER, ValadateRunnerVapiTestGathererClass))

typedef struct _ValadateRunnerVapiTestGatherer ValadateRunnerVapiTestGatherer;
typedef struct _ValadateRunnerVapiTestGathererClass ValadateRunnerVapiTestGathererClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _ValadateRunnerReaderIface {
	GTypeInterface parent_iface;
	gboolean (*process_file) (ValadateRunnerReader* self, const gchar* file, GError** error);
	void (*gather_tests) (ValadateRunnerReader* self, GError** error);
};

struct _ValadateRunnerVapiReader {
	GObject parent_instance;
	ValadateRunnerVapiReaderPrivate * priv;
};

struct _ValadateRunnerVapiReaderClass {
	GObjectClass parent_class;
};

struct _ValadateRunnerVapiReaderPrivate {
	ValaCodeContext* context;
};

typedef enum  {
	VALADATE_RUNNER_RUNNER_ERROR_UNRECOGNIZED_FILE,
	VALADATE_RUNNER_RUNNER_ERROR_CANNOT_READ,
	VALADATE_RUNNER_RUNNER_ERROR_COMPILATION_FAILED,
	VALADATE_RUNNER_RUNNER_ERROR_TYPE_NOT_LOADED,
	VALADATE_RUNNER_RUNNER_ERROR_NOT_FOUND,
	VALADATE_RUNNER_RUNNER_ERROR_VAPI_ERROR
} ValadateRunnerRunnerError;
#define VALADATE_RUNNER_RUNNER_ERROR valadate_runner_runner_error_quark ()

static gpointer valadate_runner_vapi_reader_parent_class = NULL;
extern gboolean valadate_runner_verbose;
extern gchar** valadate_runner_path;
static ValadateRunnerReaderIface* valadate_runner_vapi_reader_valadate_runner_reader_parent_iface = NULL;

GType valadate_runner_reader_get_type (void) G_GNUC_CONST;
GType valadate_runner_vapi_reader_get_type (void) G_GNUC_CONST;
#define VALADATE_RUNNER_VAPI_READER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALADATE_RUNNER_TYPE_VAPI_READER, ValadateRunnerVapiReaderPrivate))
enum  {
	VALADATE_RUNNER_VAPI_READER_DUMMY_PROPERTY
};
static gboolean valadate_runner_vapi_reader_real_process_file (ValadateRunnerReader* base, const gchar* file, GError** error);
gboolean valadate_runner_vapi_reader_add_file (ValadateRunnerVapiReader* self, const gchar* file, GError** error);
static void valadate_runner_vapi_reader_add_package (ValadateRunnerVapiReader* self, const gchar* pkg, GError** error);
static void valadate_runner_vapi_reader_real_gather_tests (ValadateRunnerReader* base, GError** error);
static void valadate_runner_vapi_reader_check (ValadateRunnerVapiReader* self, GError** error);
GType valadate_runner_vapi_test_gatherer_get_type (void) G_GNUC_CONST;
ValadateRunnerVapiTestGatherer* valadate_runner_vapi_test_gatherer_new (void);
ValadateRunnerVapiTestGatherer* valadate_runner_vapi_test_gatherer_construct (GType object_type);
void valadate_runner_vapi_test_gatherer_gather (ValadateRunnerVapiTestGatherer* self, ValaCodeContext* context);
ValadateRunnerVapiReader* valadate_runner_vapi_reader_new (GError** error);
ValadateRunnerVapiReader* valadate_runner_vapi_reader_construct (GType object_type, GError** error);
static gchar** _vala_array_dup4 (gchar** self, int length);
GQuark valadate_runner_runner_error_quark (void);
static void valadate_runner_vapi_reader_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gboolean valadate_runner_vapi_reader_real_process_file (ValadateRunnerReader* base, const gchar* file, GError** error) {
	ValadateRunnerVapiReader * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (ValadateRunnerVapiReader*) base;
	g_return_val_if_fail (file != NULL, FALSE);
	_tmp1_ = file;
	_tmp2_ = valadate_runner_vapi_reader_add_file (self, _tmp1_, &_inner_error_);
	_tmp0_ = _tmp2_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return FALSE;
	}
	result = _tmp0_;
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


gboolean valadate_runner_vapi_reader_add_file (ValadateRunnerVapiReader* self, const gchar* file, GError** error) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	ValaCodeContext* _tmp9_ = NULL;
	ValaCodeContext* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	ValaSourceFile* _tmp12_ = NULL;
	ValaSourceFile* _tmp13_ = NULL;
	gchar* deps = NULL;
	const gchar* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	gint _tmp16_ = 0;
	gint _tmp17_ = 0;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	const gchar* _tmp22_ = NULL;
	gboolean _tmp23_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file != NULL, FALSE);
	_tmp0_ = file;
	_tmp1_ = g_str_has_suffix (_tmp0_, ".vapi");
	if (!_tmp1_) {
		result = FALSE;
		return result;
	}
	_tmp2_ = valadate_runner_verbose;
	if (_tmp2_) {
		FILE* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		_tmp3_ = stdout;
		_tmp4_ = file;
		fprintf (_tmp3_, "Reading %s\n", _tmp4_);
	}
	_tmp5_ = file;
	_tmp6_ = g_file_test (_tmp5_, G_FILE_TEST_EXISTS);
	if (!_tmp6_) {
		const gchar* _tmp7_ = NULL;
		GError* _tmp8_ = NULL;
		_tmp7_ = file;
		_tmp8_ = g_error_new (G_FILE_ERROR, G_FILE_ERROR_NOENT, "%s does not exist.", _tmp7_);
		_inner_error_ = _tmp8_;
		g_propagate_error (error, _inner_error_);
		return FALSE;
	}
	_tmp9_ = self->priv->context;
	_tmp10_ = self->priv->context;
	_tmp11_ = file;
	_tmp12_ = vala_source_file_new (_tmp10_, VALA_SOURCE_FILE_TYPE_PACKAGE, _tmp11_, NULL, FALSE);
	_tmp13_ = _tmp12_;
	vala_code_context_add_source_file (_tmp9_, _tmp13_);
	_vala_source_file_unref0 (_tmp13_);
	_tmp14_ = file;
	_tmp15_ = file;
	_tmp16_ = strlen (_tmp15_);
	_tmp17_ = _tmp16_;
	_tmp18_ = string_substring (_tmp14_, (glong) 0, (glong) (_tmp17_ - 4));
	_tmp19_ = _tmp18_;
	_tmp20_ = g_strconcat (_tmp19_, "deps", NULL);
	_tmp21_ = _tmp20_;
	_g_free0 (_tmp19_);
	deps = _tmp21_;
	_tmp22_ = deps;
	_tmp23_ = g_file_test (_tmp22_, G_FILE_TEST_EXISTS);
	if (_tmp23_) {
		gchar* deps_content = NULL;
		const gchar* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		gchar** _tmp27_ = NULL;
		gchar** _tmp28_ = NULL;
		_tmp24_ = deps;
		g_file_get_contents (_tmp24_, &_tmp25_, NULL, &_inner_error_);
		_g_free0 (deps_content);
		deps_content = _tmp25_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (deps_content);
			_g_free0 (deps);
			return FALSE;
		}
		_tmp26_ = deps_content;
		_tmp28_ = _tmp27_ = g_strsplit (_tmp26_, "\n", 0);
		{
			gchar** dep_collection = NULL;
			gint dep_collection_length1 = 0;
			gint _dep_collection_size_ = 0;
			gint dep_it = 0;
			dep_collection = _tmp28_;
			dep_collection_length1 = _vala_array_length (_tmp27_);
			for (dep_it = 0; dep_it < _vala_array_length (_tmp27_); dep_it = dep_it + 1) {
				gchar* _tmp29_ = NULL;
				gchar* dep = NULL;
				_tmp29_ = g_strdup (dep_collection[dep_it]);
				dep = _tmp29_;
				{
					const gchar* _tmp30_ = NULL;
					gchar* _tmp31_ = NULL;
					const gchar* _tmp32_ = NULL;
					_tmp30_ = dep;
					_tmp31_ = string_strip (_tmp30_);
					_g_free0 (dep);
					dep = _tmp31_;
					_tmp32_ = dep;
					if (g_strcmp0 (_tmp32_, "") != 0) {
						const gchar* _tmp33_ = NULL;
						_tmp33_ = dep;
						valadate_runner_vapi_reader_add_package (self, _tmp33_, &_inner_error_);
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (dep);
							dep_collection = (_vala_array_free (dep_collection, dep_collection_length1, (GDestroyNotify) g_free), NULL);
							_g_free0 (deps_content);
							_g_free0 (deps);
							return FALSE;
						}
					}
					_g_free0 (dep);
				}
			}
			dep_collection = (_vala_array_free (dep_collection, dep_collection_length1, (GDestroyNotify) g_free), NULL);
		}
		_g_free0 (deps_content);
	}
	result = TRUE;
	_g_free0 (deps);
	return result;
}


static void valadate_runner_vapi_reader_real_gather_tests (ValadateRunnerReader* base, GError** error) {
	ValadateRunnerVapiReader * self;
	gboolean _tmp0_ = FALSE;
	ValaParser* parser = NULL;
	ValaParser* _tmp2_ = NULL;
	ValaParser* _tmp3_ = NULL;
	ValaCodeContext* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	ValaSymbolResolver* resolver = NULL;
	ValaSymbolResolver* _tmp7_ = NULL;
	ValaSymbolResolver* _tmp8_ = NULL;
	ValaCodeContext* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	ValadateRunnerVapiTestGatherer* gatherer = NULL;
	ValadateRunnerVapiTestGatherer* _tmp12_ = NULL;
	ValadateRunnerVapiTestGatherer* _tmp13_ = NULL;
	ValaCodeContext* _tmp14_ = NULL;
	GError * _inner_error_ = NULL;
	self = (ValadateRunnerVapiReader*) base;
	valadate_runner_vapi_reader_check (self, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	_tmp0_ = valadate_runner_verbose;
	if (_tmp0_) {
		FILE* _tmp1_ = NULL;
		_tmp1_ = stdout;
		fprintf (_tmp1_, "Parsing...\n");
	}
	_tmp2_ = vala_parser_new ();
	parser = _tmp2_;
	_tmp3_ = parser;
	_tmp4_ = self->priv->context;
	vala_parser_parse (_tmp3_, _tmp4_);
	valadate_runner_vapi_reader_check (self, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_vala_code_visitor_unref0 (parser);
		return;
	}
	_tmp5_ = valadate_runner_verbose;
	if (_tmp5_) {
		FILE* _tmp6_ = NULL;
		_tmp6_ = stdout;
		fprintf (_tmp6_, "Resolving...\n");
	}
	_tmp7_ = vala_symbol_resolver_new ();
	resolver = _tmp7_;
	_tmp8_ = resolver;
	_tmp9_ = self->priv->context;
	vala_symbol_resolver_resolve (_tmp8_, _tmp9_);
	valadate_runner_vapi_reader_check (self, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_vala_code_visitor_unref0 (resolver);
		_vala_code_visitor_unref0 (parser);
		return;
	}
	_tmp10_ = valadate_runner_verbose;
	if (_tmp10_) {
		FILE* _tmp11_ = NULL;
		_tmp11_ = stdout;
		fprintf (_tmp11_, "Gathering tests...\n");
	}
	_tmp12_ = valadate_runner_vapi_test_gatherer_new ();
	gatherer = _tmp12_;
	_tmp13_ = gatherer;
	_tmp14_ = self->priv->context;
	valadate_runner_vapi_test_gatherer_gather (_tmp13_, _tmp14_);
	_vala_code_visitor_unref0 (gatherer);
	_vala_code_visitor_unref0 (resolver);
	_vala_code_visitor_unref0 (parser);
}


ValadateRunnerVapiReader* valadate_runner_vapi_reader_construct (GType object_type, GError** error) {
	ValadateRunnerVapiReader * self = NULL;
	ValaCodeContext* _tmp0_ = NULL;
	ValaCodeContext* _tmp1_ = NULL;
	ValaCodeContext* _tmp2_ = NULL;
	ValaCodeContext* _tmp3_ = NULL;
	ValaCodeContext* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	self = (ValadateRunnerVapiReader*) g_object_new (object_type, NULL);
	_tmp0_ = vala_code_context_new ();
	_vala_code_context_unref0 (self->priv->context);
	self->priv->context = _tmp0_;
	_tmp1_ = self->priv->context;
	vala_code_context_push (_tmp1_);
	_tmp2_ = self->priv->context;
	vala_code_context_set_ccode_only (_tmp2_, TRUE);
	_tmp3_ = self->priv->context;
	vala_code_context_set_profile (_tmp3_, VALA_PROFILE_GOBJECT);
	_tmp4_ = self->priv->context;
	vala_code_context_add_define (_tmp4_, "GOBJECT");
	valadate_runner_vapi_reader_add_package (self, "glib-2.0", &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (self);
		return NULL;
	}
	valadate_runner_vapi_reader_add_package (self, "gobject-2.0", &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (self);
		return NULL;
	}
	valadate_runner_vapi_reader_add_package (self, "gio-2.0", &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (self);
		return NULL;
	}
	valadate_runner_vapi_reader_add_package (self, "valadate-1.0", &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (self);
		return NULL;
	}
	return self;
}


ValadateRunnerVapiReader* valadate_runner_vapi_reader_new (GError** error) {
	return valadate_runner_vapi_reader_construct (VALADATE_RUNNER_TYPE_VAPI_READER, error);
}


static gchar** _vala_array_dup4 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static void valadate_runner_vapi_reader_add_package (ValadateRunnerVapiReader* self, const gchar* pkg, GError** error) {
	gboolean _tmp0_ = FALSE;
	ValaCodeContext* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	ValaCodeContext* _tmp6_ = NULL;
	gchar** _tmp7_ = NULL;
	gint _tmp7__length1 = 0;
	gchar** _tmp8_ = NULL;
	gint _tmp8__length1 = 0;
	gchar* pkg_path = NULL;
	ValaCodeContext* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	ValaCodeContext* _tmp15_ = NULL;
	const gchar* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (pkg != NULL);
	_tmp0_ = valadate_runner_verbose;
	if (_tmp0_) {
		FILE* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		_tmp1_ = stdout;
		_tmp2_ = pkg;
		fprintf (_tmp1_, "Adding package %s\n", _tmp2_);
	}
	_tmp3_ = self->priv->context;
	_tmp4_ = pkg;
	_tmp5_ = vala_code_context_has_package (_tmp3_, _tmp4_);
	if (_tmp5_) {
		return;
	}
	_tmp6_ = self->priv->context;
	_tmp7_ = valadate_runner_path;
	_tmp7__length1 = _vala_array_length (valadate_runner_path);
	_tmp8_ = (_tmp7_ != NULL) ? _vala_array_dup4 (_tmp7_, _tmp7__length1) : ((gpointer) _tmp7_);
	_tmp8__length1 = _tmp7__length1;
	_tmp6_->vapi_directories = (_vala_array_free (_tmp6_->vapi_directories, _tmp6_->vapi_directories_length1, (GDestroyNotify) g_free), NULL);
	_tmp6_->vapi_directories = _tmp8_;
	_tmp6_->vapi_directories_length1 = _tmp8__length1;
	_tmp9_ = self->priv->context;
	_tmp10_ = pkg;
	_tmp11_ = vala_code_context_get_vapi_path (_tmp9_, _tmp10_);
	pkg_path = _tmp11_;
	_tmp12_ = pkg_path;
	if (_tmp12_ == NULL) {
		const gchar* _tmp13_ = NULL;
		GError* _tmp14_ = NULL;
		_tmp13_ = pkg;
		_tmp14_ = g_error_new (VALADATE_RUNNER_RUNNER_ERROR, VALADATE_RUNNER_RUNNER_ERROR_NOT_FOUND, "Dependent package %s was not found. Need to add search dir?", _tmp13_);
		_inner_error_ = _tmp14_;
		g_propagate_error (error, _inner_error_);
		_g_free0 (pkg_path);
		return;
	}
	_tmp15_ = self->priv->context;
	_tmp16_ = pkg;
	vala_code_context_add_package (_tmp15_, _tmp16_);
	_tmp17_ = pkg_path;
	valadate_runner_vapi_reader_add_file (self, _tmp17_, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_free0 (pkg_path);
		return;
	}
	_g_free0 (pkg_path);
}


static void valadate_runner_vapi_reader_check (ValadateRunnerVapiReader* self, GError** error) {
	ValaCodeContext* _tmp0_ = NULL;
	ValaReport* _tmp1_ = NULL;
	ValaReport* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->context;
	_tmp1_ = vala_code_context_get_report (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = vala_report_get_errors (_tmp2_);
	if (_tmp3_ > 0) {
		ValaCodeContext* _tmp4_ = NULL;
		ValaReport* _tmp5_ = NULL;
		ValaReport* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		GError* _tmp8_ = NULL;
		_tmp4_ = self->priv->context;
		_tmp5_ = vala_code_context_get_report (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = vala_report_get_errors (_tmp6_);
		_tmp8_ = g_error_new (VALADATE_RUNNER_RUNNER_ERROR, VALADATE_RUNNER_RUNNER_ERROR_VAPI_ERROR, "Found %i errors parsing specified vapi files.", _tmp7_);
		_inner_error_ = _tmp8_;
		g_propagate_error (error, _inner_error_);
		return;
	}
}


static void valadate_runner_vapi_reader_class_init (ValadateRunnerVapiReaderClass * klass) {
	valadate_runner_vapi_reader_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ValadateRunnerVapiReaderPrivate));
	G_OBJECT_CLASS (klass)->finalize = valadate_runner_vapi_reader_finalize;
}


static void valadate_runner_vapi_reader_valadate_runner_reader_interface_init (ValadateRunnerReaderIface * iface) {
	valadate_runner_vapi_reader_valadate_runner_reader_parent_iface = g_type_interface_peek_parent (iface);
	iface->process_file = (gboolean (*)(ValadateRunnerReader*, const gchar*, GError**)) valadate_runner_vapi_reader_real_process_file;
	iface->gather_tests = (void (*)(ValadateRunnerReader*, GError**)) valadate_runner_vapi_reader_real_gather_tests;
}


static void valadate_runner_vapi_reader_instance_init (ValadateRunnerVapiReader * self) {
	self->priv = VALADATE_RUNNER_VAPI_READER_GET_PRIVATE (self);
}


static void valadate_runner_vapi_reader_finalize (GObject* obj) {
	ValadateRunnerVapiReader * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADATE_RUNNER_TYPE_VAPI_READER, ValadateRunnerVapiReader);
	vala_code_context_pop ();
	_vala_code_context_unref0 (self->priv->context);
	G_OBJECT_CLASS (valadate_runner_vapi_reader_parent_class)->finalize (obj);
}


GType valadate_runner_vapi_reader_get_type (void) {
	static volatile gsize valadate_runner_vapi_reader_type_id__volatile = 0;
	if (g_once_init_enter (&valadate_runner_vapi_reader_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadateRunnerVapiReaderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadate_runner_vapi_reader_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadateRunnerVapiReader), 0, (GInstanceInitFunc) valadate_runner_vapi_reader_instance_init, NULL };
		static const GInterfaceInfo valadate_runner_reader_info = { (GInterfaceInitFunc) valadate_runner_vapi_reader_valadate_runner_reader_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType valadate_runner_vapi_reader_type_id;
		valadate_runner_vapi_reader_type_id = g_type_register_static (G_TYPE_OBJECT, "ValadateRunnerVapiReader", &g_define_type_info, 0);
		g_type_add_interface_static (valadate_runner_vapi_reader_type_id, VALADATE_RUNNER_TYPE_READER, &valadate_runner_reader_info);
		g_once_init_leave (&valadate_runner_vapi_reader_type_id__volatile, valadate_runner_vapi_reader_type_id);
	}
	return valadate_runner_vapi_reader_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




/* vapitestgatherer.c generated by valac 0.30.0, the Vala compiler
 * generated from vapitestgatherer.vala, do not modify */

/*
 * Valadate - Unit testing library for GObject-based libraries.
 * Copyright (C) 2009  Jan Hudec <bulb@ucw.cz>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <vala.h>
#include <stdio.h>
#include <valacodegen.h>
#include <valagee.h>


#define VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER (valadate_runner_vapi_test_gatherer_get_type ())
#define VALADATE_RUNNER_VAPI_TEST_GATHERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER, ValadateRunnerVapiTestGatherer))
#define VALADATE_RUNNER_VAPI_TEST_GATHERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER, ValadateRunnerVapiTestGathererClass))
#define VALADATE_RUNNER_IS_VAPI_TEST_GATHERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER))
#define VALADATE_RUNNER_IS_VAPI_TEST_GATHERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER))
#define VALADATE_RUNNER_VAPI_TEST_GATHERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER, ValadateRunnerVapiTestGathererClass))

typedef struct _ValadateRunnerVapiTestGatherer ValadateRunnerVapiTestGatherer;
typedef struct _ValadateRunnerVapiTestGathererClass ValadateRunnerVapiTestGathererClass;
typedef struct _ValadateRunnerVapiTestGathererPrivate ValadateRunnerVapiTestGathererPrivate;

#define VALADATE_RUNNER_TYPE_SUITE_INFO (valadate_runner_suite_info_get_type ())
#define VALADATE_RUNNER_SUITE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_SUITE_INFO, ValadateRunnerSuiteInfo))
#define VALADATE_RUNNER_SUITE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADATE_RUNNER_TYPE_SUITE_INFO, ValadateRunnerSuiteInfoClass))
#define VALADATE_RUNNER_IS_SUITE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_SUITE_INFO))
#define VALADATE_RUNNER_IS_SUITE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADATE_RUNNER_TYPE_SUITE_INFO))
#define VALADATE_RUNNER_SUITE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADATE_RUNNER_TYPE_SUITE_INFO, ValadateRunnerSuiteInfoClass))

typedef struct _ValadateRunnerSuiteInfo ValadateRunnerSuiteInfo;
typedef struct _ValadateRunnerSuiteInfoClass ValadateRunnerSuiteInfoClass;

#define VALADATE_RUNNER_TYPE_VAPI_SUITE_INFO (valadate_runner_vapi_suite_info_get_type ())
#define VALADATE_RUNNER_VAPI_SUITE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_VAPI_SUITE_INFO, ValadateRunnerVapiSuiteInfo))
#define VALADATE_RUNNER_VAPI_SUITE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADATE_RUNNER_TYPE_VAPI_SUITE_INFO, ValadateRunnerVapiSuiteInfoClass))
#define VALADATE_RUNNER_IS_VAPI_SUITE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_VAPI_SUITE_INFO))
#define VALADATE_RUNNER_IS_VAPI_SUITE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADATE_RUNNER_TYPE_VAPI_SUITE_INFO))
#define VALADATE_RUNNER_VAPI_SUITE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADATE_RUNNER_TYPE_VAPI_SUITE_INFO, ValadateRunnerVapiSuiteInfoClass))

typedef struct _ValadateRunnerVapiSuiteInfo ValadateRunnerVapiSuiteInfo;
typedef struct _ValadateRunnerVapiSuiteInfoClass ValadateRunnerVapiSuiteInfoClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _valadate_runner_suite_info_unref0(var) ((var == NULL) ? NULL : (var = (valadate_runner_suite_info_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))
#define _vala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (vala_iterable_unref (var), NULL)))

struct _ValadateRunnerVapiTestGatherer {
	ValaCodeVisitor parent_instance;
	ValadateRunnerVapiTestGathererPrivate * priv;
};

struct _ValadateRunnerVapiTestGathererClass {
	ValaCodeVisitorClass parent_class;
};

struct _ValadateRunnerVapiTestGathererPrivate {
	GTestSuite* current_suite;
};

typedef enum  {
	VALADATE_RUNNER_RUNNER_ERROR_UNRECOGNIZED_FILE,
	VALADATE_RUNNER_RUNNER_ERROR_CANNOT_READ,
	VALADATE_RUNNER_RUNNER_ERROR_COMPILATION_FAILED,
	VALADATE_RUNNER_RUNNER_ERROR_TYPE_NOT_LOADED,
	VALADATE_RUNNER_RUNNER_ERROR_NOT_FOUND,
	VALADATE_RUNNER_RUNNER_ERROR_VAPI_ERROR
} ValadateRunnerRunnerError;
#define VALADATE_RUNNER_RUNNER_ERROR valadate_runner_runner_error_quark ()

static gpointer valadate_runner_vapi_test_gatherer_parent_class = NULL;
static GSList* valadate_runner_vapi_test_gatherer_suites;
static GSList* valadate_runner_vapi_test_gatherer_suites = NULL;
extern gboolean valadate_runner_verbose;

GType valadate_runner_vapi_test_gatherer_get_type (void) G_GNUC_CONST;
#define VALADATE_RUNNER_VAPI_TEST_GATHERER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER, ValadateRunnerVapiTestGathererPrivate))
enum  {
	VALADATE_RUNNER_VAPI_TEST_GATHERER_DUMMY_PROPERTY
};
gpointer valadate_runner_suite_info_ref (gpointer instance);
void valadate_runner_suite_info_unref (gpointer instance);
GParamSpec* valadate_runner_param_spec_suite_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void valadate_runner_value_set_suite_info (GValue* value, gpointer v_object);
void valadate_runner_value_take_suite_info (GValue* value, gpointer v_object);
gpointer valadate_runner_value_get_suite_info (const GValue* value);
GType valadate_runner_suite_info_get_type (void) G_GNUC_CONST;
GType valadate_runner_vapi_suite_info_get_type (void) G_GNUC_CONST;
void valadate_runner_vapi_test_gatherer_gather (ValadateRunnerVapiTestGatherer* self, ValaCodeContext* context);
static void valadate_runner_vapi_test_gatherer_real_visit_namespace (ValaCodeVisitor* base, ValaNamespace* ns);
static void valadate_runner_vapi_test_gatherer_real_visit_class (ValaCodeVisitor* base, ValaClass* cl);
static gboolean valadate_runner_vapi_test_gatherer_is_fixture (ValadateRunnerVapiTestGatherer* self, ValaClass* cl);
GQuark valadate_runner_runner_error_quark (void);
ValadateRunnerVapiSuiteInfo* valadate_runner_vapi_suite_info_new (ValaClass* cl, GError** error);
ValadateRunnerVapiSuiteInfo* valadate_runner_vapi_suite_info_construct (GType object_type, ValaClass* cl, GError** error);
void valadate_runner_vapi_suite_info_create_tests (ValadateRunnerVapiSuiteInfo* self, GTestSuite* suite, GError** error);
ValadateRunnerVapiTestGatherer* valadate_runner_vapi_test_gatherer_new (void);
ValadateRunnerVapiTestGatherer* valadate_runner_vapi_test_gatherer_construct (GType object_type);
static void valadate_runner_vapi_test_gatherer_finalize (ValaCodeVisitor* obj);


void valadate_runner_vapi_test_gatherer_gather (ValadateRunnerVapiTestGatherer* self, ValaCodeContext* context) {
	ValaCodeContext* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = context;
	vala_code_context_accept (_tmp0_, (ValaCodeVisitor*) self);
}


static void valadate_runner_vapi_test_gatherer_real_visit_namespace (ValaCodeVisitor* base, ValaNamespace* ns) {
	ValadateRunnerVapiTestGatherer * self;
	gboolean _tmp0_ = FALSE;
	GTestSuite* prev_suite = NULL;
	GTestSuite* _tmp5_ = NULL;
	ValaNamespace* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	ValaNamespace* _tmp16_ = NULL;
	GTestSuite* _tmp17_ = NULL;
	self = (ValadateRunnerVapiTestGatherer*) base;
	g_return_if_fail (ns != NULL);
	_tmp0_ = valadate_runner_verbose;
	if (_tmp0_) {
		FILE* _tmp1_ = NULL;
		ValaNamespace* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		_tmp1_ = stdout;
		_tmp2_ = ns;
		_tmp3_ = vala_symbol_get_name ((ValaSymbol*) _tmp2_);
		_tmp4_ = _tmp3_;
		fprintf (_tmp1_, "Scanning namespace %s...\n", _tmp4_);
	}
	_tmp5_ = self->priv->current_suite;
	prev_suite = _tmp5_;
	_tmp6_ = ns;
	_tmp7_ = vala_symbol_get_name ((ValaSymbol*) _tmp6_);
	_tmp8_ = _tmp7_;
	if (_tmp8_ == NULL) {
		GTestSuite* _tmp9_ = NULL;
		_tmp9_ = g_test_get_root ();
		self->priv->current_suite = _tmp9_;
	} else {
		ValaNamespace* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		GTestSuite* _tmp13_ = NULL;
		GTestSuite* _tmp14_ = NULL;
		GTestSuite* _tmp15_ = NULL;
		_tmp10_ = ns;
		_tmp11_ = vala_symbol_get_name ((ValaSymbol*) _tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_test_create_suite (_tmp12_);
		self->priv->current_suite = _tmp13_;
		_tmp14_ = prev_suite;
		_tmp15_ = self->priv->current_suite;
		g_test_suite_add_suite (_tmp14_, _tmp15_);
	}
	_tmp16_ = ns;
	vala_code_node_accept_children ((ValaCodeNode*) _tmp16_, (ValaCodeVisitor*) self);
	_tmp17_ = prev_suite;
	self->priv->current_suite = _tmp17_;
}


static void valadate_runner_vapi_test_gatherer_real_visit_class (ValaCodeVisitor* base, ValaClass* cl) {
	ValadateRunnerVapiTestGatherer * self;
	ValaClass* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	GError * _inner_error_ = NULL;
	self = (ValadateRunnerVapiTestGatherer*) base;
	g_return_if_fail (cl != NULL);
	_tmp0_ = cl;
	_tmp1_ = valadate_runner_vapi_test_gatherer_is_fixture (self, _tmp0_);
	if (!_tmp1_) {
		return;
	}
	_tmp2_ = valadate_runner_verbose;
	if (_tmp2_) {
		FILE* _tmp3_ = NULL;
		ValaClass* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		ValaClass* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp3_ = stdout;
		_tmp4_ = cl;
		_tmp5_ = vala_symbol_get_full_name ((ValaSymbol*) _tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = cl;
		_tmp8_ = vala_ccode_base_module_get_ccode_lower_case_prefix ((ValaSymbol*) _tmp7_);
		_tmp9_ = _tmp8_;
		fprintf (_tmp3_, "    Found fixture %s (%sget_type)\n", _tmp6_, _tmp9_);
		_g_free0 (_tmp9_);
		_g_free0 (_tmp6_);
	}
	{
		ValadateRunnerVapiSuiteInfo* suite_info = NULL;
		ValaClass* _tmp10_ = NULL;
		ValadateRunnerVapiSuiteInfo* _tmp11_ = NULL;
		GTestSuite* suite = NULL;
		ValaClass* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		GTestSuite* _tmp15_ = NULL;
		ValadateRunnerVapiSuiteInfo* _tmp16_ = NULL;
		GTestSuite* _tmp17_ = NULL;
		GTestSuite* _tmp18_ = NULL;
		GTestSuite* _tmp19_ = NULL;
		ValadateRunnerVapiSuiteInfo* _tmp20_ = NULL;
		_tmp10_ = cl;
		_tmp11_ = valadate_runner_vapi_suite_info_new (_tmp10_, &_inner_error_);
		suite_info = _tmp11_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADATE_RUNNER_RUNNER_ERROR) {
				goto __catch1_valadate_runner_runner_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp12_ = cl;
		_tmp13_ = vala_symbol_get_name ((ValaSymbol*) _tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_test_create_suite (_tmp14_);
		suite = _tmp15_;
		_tmp16_ = suite_info;
		_tmp17_ = suite;
		valadate_runner_vapi_suite_info_create_tests (_tmp16_, _tmp17_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_valadate_runner_suite_info_unref0 (suite_info);
			if (_inner_error_->domain == VALADATE_RUNNER_RUNNER_ERROR) {
				goto __catch1_valadate_runner_runner_error;
			}
			_valadate_runner_suite_info_unref0 (suite_info);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp18_ = self->priv->current_suite;
		_tmp19_ = suite;
		g_test_suite_add_suite (_tmp18_, _tmp19_);
		_tmp20_ = suite_info;
		suite_info = NULL;
		valadate_runner_vapi_test_gatherer_suites = g_slist_prepend (valadate_runner_vapi_test_gatherer_suites, _tmp20_);
		_valadate_runner_suite_info_unref0 (suite_info);
	}
	goto __finally1;
	__catch1_valadate_runner_runner_error:
	{
		GError* e = NULL;
		FILE* _tmp21_ = NULL;
		GError* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp21_ = stderr;
		_tmp22_ = e;
		_tmp23_ = _tmp22_->message;
		fprintf (_tmp21_, "Error: %s\n", _tmp23_);
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static gpointer _vala_code_node_ref0 (gpointer self) {
	return self ? vala_code_node_ref (self) : NULL;
}


static gboolean valadate_runner_vapi_test_gatherer_is_fixture (ValadateRunnerVapiTestGatherer* self, ValaClass* cl) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (cl != NULL, FALSE);
	{
		ValaList* _base_type_list = NULL;
		ValaClass* _tmp0_ = NULL;
		ValaList* _tmp1_ = NULL;
		gint _base_type_size = 0;
		ValaList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _base_type_index = 0;
		_tmp0_ = cl;
		_tmp1_ = vala_class_get_base_types (_tmp0_);
		_base_type_list = _tmp1_;
		_tmp2_ = _base_type_list;
		_tmp3_ = vala_collection_get_size ((ValaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_base_type_size = _tmp4_;
		_base_type_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			ValaDataType* base_type = NULL;
			ValaList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			ValaObjectType* obj_type = NULL;
			ValaDataType* _tmp11_ = NULL;
			ValaObjectType* _tmp12_ = NULL;
			ValaObjectType* _tmp13_ = NULL;
			ValaObjectTypeSymbol* _tmp14_ = NULL;
			ValaObjectTypeSymbol* _tmp15_ = NULL;
			gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			gboolean _tmp18_ = FALSE;
			_tmp5_ = _base_type_index;
			_base_type_index = _tmp5_ + 1;
			_tmp6_ = _base_type_index;
			_tmp7_ = _base_type_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _base_type_list;
			_tmp9_ = _base_type_index;
			_tmp10_ = vala_list_get (_tmp8_, _tmp9_);
			base_type = (ValaDataType*) _tmp10_;
			_tmp11_ = base_type;
			_tmp12_ = _vala_code_node_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp11_, VALA_TYPE_OBJECT_TYPE, ValaObjectType));
			obj_type = _tmp12_;
			_tmp13_ = obj_type;
			_tmp14_ = vala_object_type_get_type_symbol (_tmp13_);
			_tmp15_ = _tmp14_;
			_tmp16_ = vala_symbol_get_full_name ((ValaSymbol*) _tmp15_);
			_tmp17_ = _tmp16_;
			_tmp18_ = g_strcmp0 (_tmp17_, "Valadate.Fixture") == 0;
			_g_free0 (_tmp17_);
			if (_tmp18_) {
				result = TRUE;
				_vala_code_node_unref0 (obj_type);
				_vala_code_node_unref0 (base_type);
				_vala_iterable_unref0 (_base_type_list);
				return result;
			}
			_vala_code_node_unref0 (obj_type);
			_vala_code_node_unref0 (base_type);
		}
		_vala_iterable_unref0 (_base_type_list);
	}
	result = FALSE;
	return result;
}


ValadateRunnerVapiTestGatherer* valadate_runner_vapi_test_gatherer_construct (GType object_type) {
	ValadateRunnerVapiTestGatherer* self = NULL;
	self = (ValadateRunnerVapiTestGatherer*) vala_code_visitor_construct (object_type);
	return self;
}


ValadateRunnerVapiTestGatherer* valadate_runner_vapi_test_gatherer_new (void) {
	return valadate_runner_vapi_test_gatherer_construct (VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER);
}


static void valadate_runner_vapi_test_gatherer_class_init (ValadateRunnerVapiTestGathererClass * klass) {
	valadate_runner_vapi_test_gatherer_parent_class = g_type_class_peek_parent (klass);
	((ValaCodeVisitorClass *) klass)->finalize = valadate_runner_vapi_test_gatherer_finalize;
	g_type_class_add_private (klass, sizeof (ValadateRunnerVapiTestGathererPrivate));
	((ValaCodeVisitorClass *) klass)->visit_namespace = valadate_runner_vapi_test_gatherer_real_visit_namespace;
	((ValaCodeVisitorClass *) klass)->visit_class = valadate_runner_vapi_test_gatherer_real_visit_class;
}


static void valadate_runner_vapi_test_gatherer_instance_init (ValadateRunnerVapiTestGatherer * self) {
	self->priv = VALADATE_RUNNER_VAPI_TEST_GATHERER_GET_PRIVATE (self);
	self->priv->current_suite = NULL;
}


static void valadate_runner_vapi_test_gatherer_finalize (ValaCodeVisitor* obj) {
	ValadateRunnerVapiTestGatherer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADATE_RUNNER_TYPE_VAPI_TEST_GATHERER, ValadateRunnerVapiTestGatherer);
	VALA_CODE_VISITOR_CLASS (valadate_runner_vapi_test_gatherer_parent_class)->finalize (obj);
}


GType valadate_runner_vapi_test_gatherer_get_type (void) {
	static volatile gsize valadate_runner_vapi_test_gatherer_type_id__volatile = 0;
	if (g_once_init_enter (&valadate_runner_vapi_test_gatherer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadateRunnerVapiTestGathererClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadate_runner_vapi_test_gatherer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadateRunnerVapiTestGatherer), 0, (GInstanceInitFunc) valadate_runner_vapi_test_gatherer_instance_init, NULL };
		GType valadate_runner_vapi_test_gatherer_type_id;
		valadate_runner_vapi_test_gatherer_type_id = g_type_register_static (VALA_TYPE_CODE_VISITOR, "ValadateRunnerVapiTestGatherer", &g_define_type_info, 0);
		g_once_init_leave (&valadate_runner_vapi_test_gatherer_type_id__volatile, valadate_runner_vapi_test_gatherer_type_id);
	}
	return valadate_runner_vapi_test_gatherer_type_id__volatile;
}




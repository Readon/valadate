/* runner.c generated by valac 0.30.0, the Vala compiler
 * generated from runner.vala, do not modify */

/*
 * Valadate - Unit testing library for GObject-based libraries.
 * Copyright (C) 2009  Jan Hudec <bulb@ucw.cz>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#define VALADATE_RUNNER_TYPE_READER (valadate_runner_reader_get_type ())
#define VALADATE_RUNNER_READER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_READER, ValadateRunnerReader))
#define VALADATE_RUNNER_IS_READER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_READER))
#define VALADATE_RUNNER_READER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), VALADATE_RUNNER_TYPE_READER, ValadateRunnerReaderIface))

typedef struct _ValadateRunnerReader ValadateRunnerReader;
typedef struct _ValadateRunnerReaderIface ValadateRunnerReaderIface;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

#define VALADATE_RUNNER_TYPE_GIR_READER (valadate_runner_gir_reader_get_type ())
#define VALADATE_RUNNER_GIR_READER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_GIR_READER, ValadateRunnerGirReader))
#define VALADATE_RUNNER_GIR_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADATE_RUNNER_TYPE_GIR_READER, ValadateRunnerGirReaderClass))
#define VALADATE_RUNNER_IS_GIR_READER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_GIR_READER))
#define VALADATE_RUNNER_IS_GIR_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADATE_RUNNER_TYPE_GIR_READER))
#define VALADATE_RUNNER_GIR_READER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADATE_RUNNER_TYPE_GIR_READER, ValadateRunnerGirReaderClass))

typedef struct _ValadateRunnerGirReader ValadateRunnerGirReader;
typedef struct _ValadateRunnerGirReaderClass ValadateRunnerGirReaderClass;

#define VALADATE_RUNNER_TYPE_VAPI_READER (valadate_runner_vapi_reader_get_type ())
#define VALADATE_RUNNER_VAPI_READER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADATE_RUNNER_TYPE_VAPI_READER, ValadateRunnerVapiReader))
#define VALADATE_RUNNER_VAPI_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADATE_RUNNER_TYPE_VAPI_READER, ValadateRunnerVapiReaderClass))
#define VALADATE_RUNNER_IS_VAPI_READER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADATE_RUNNER_TYPE_VAPI_READER))
#define VALADATE_RUNNER_IS_VAPI_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADATE_RUNNER_TYPE_VAPI_READER))
#define VALADATE_RUNNER_VAPI_READER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADATE_RUNNER_TYPE_VAPI_READER, ValadateRunnerVapiReaderClass))

typedef struct _ValadateRunnerVapiReader ValadateRunnerVapiReader;
typedef struct _ValadateRunnerVapiReaderClass ValadateRunnerVapiReaderClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _ValadateRunnerReaderIface {
	GTypeInterface parent_iface;
	gboolean (*process_file) (ValadateRunnerReader* self, const gchar* file, GError** error);
	void (*gather_tests) (ValadateRunnerReader* self, GError** error);
};

typedef enum  {
	VALADATE_RUNNER_RUNNER_ERROR_UNRECOGNIZED_FILE,
	VALADATE_RUNNER_RUNNER_ERROR_CANNOT_READ,
	VALADATE_RUNNER_RUNNER_ERROR_COMPILATION_FAILED,
	VALADATE_RUNNER_RUNNER_ERROR_TYPE_NOT_LOADED,
	VALADATE_RUNNER_RUNNER_ERROR_NOT_FOUND,
	VALADATE_RUNNER_RUNNER_ERROR_VAPI_ERROR
} ValadateRunnerRunnerError;
#define VALADATE_RUNNER_RUNNER_ERROR valadate_runner_runner_error_quark ()

extern gchar** valadate_runner_files;
gchar** valadate_runner_files = NULL;
extern gchar** valadate_runner_libs;
gchar** valadate_runner_libs = NULL;
extern gint valadate_runner_nextlib;
gint valadate_runner_nextlib = 0;
extern gchar** valadate_runner_path;
gchar** valadate_runner_path = NULL;
extern gboolean valadate_runner_verbose;
gboolean valadate_runner_verbose = FALSE;
extern GSList* valadate_runner_readers;
GSList* valadate_runner_readers = NULL;

GType valadate_runner_reader_get_type (void) G_GNUC_CONST;
gboolean valadate_runner_reader_process_file (ValadateRunnerReader* self, const gchar* file, GError** error);
void valadate_runner_reader_gather_tests (ValadateRunnerReader* self, GError** error);
GQuark valadate_runner_runner_error_quark (void);
void valadate_runner_process_file (const gchar* file, GError** error);
void valadate_runner_gather_tests (GError** error);
gint valadate_runner_main (gchar** args, int args_length1);
ValadateRunnerGirReader* valadate_runner_gir_reader_new (void);
ValadateRunnerGirReader* valadate_runner_gir_reader_construct (GType object_type);
GType valadate_runner_gir_reader_get_type (void) G_GNUC_CONST;
GType valadate_runner_vapi_reader_get_type (void) G_GNUC_CONST;
ValadateRunnerVapiReader* valadate_runner_vapi_reader_new (GError** error);
ValadateRunnerVapiReader* valadate_runner_vapi_reader_construct (GType object_type, GError** error);
static gint _vala_array_length (gpointer array);

const GOptionEntry VALADATE_RUNNER_options[5] = {{"library", 'L', 0, G_OPTION_ARG_FILENAME_ARRAY, &valadate_runner_libs, "Shared library corresponding to the test file", "LIB"}, {"dir", 'd', 0, G_OPTION_ARG_FILENAME_ARRAY, &valadate_runner_path, "Additional search directory for vapi and/or typelib files", "DIR"}, {"verbose-search", 'V', 0, G_OPTION_ARG_NONE, &valadate_runner_verbose, "Report classes and methods found", ""}, {"file", 'f', 0, G_OPTION_ARG_FILENAME_ARRAY, &valadate_runner_files, "gir or typelib file of test modules to run", "FILE"}, {NULL, (gchar) 0, 0, 0, NULL, NULL, NULL}};

gboolean valadate_runner_reader_process_file (ValadateRunnerReader* self, const gchar* file, GError** error) {
	g_return_val_if_fail (self != NULL, FALSE);
	return VALADATE_RUNNER_READER_GET_INTERFACE (self)->process_file (self, file, error);
}


void valadate_runner_reader_gather_tests (ValadateRunnerReader* self, GError** error) {
	g_return_if_fail (self != NULL);
	VALADATE_RUNNER_READER_GET_INTERFACE (self)->gather_tests (self, error);
}


static void valadate_runner_reader_base_init (ValadateRunnerReaderIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType valadate_runner_reader_get_type (void) {
	static volatile gsize valadate_runner_reader_type_id__volatile = 0;
	if (g_once_init_enter (&valadate_runner_reader_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadateRunnerReaderIface), (GBaseInitFunc) valadate_runner_reader_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType valadate_runner_reader_type_id;
		valadate_runner_reader_type_id = g_type_register_static (G_TYPE_INTERFACE, "ValadateRunnerReader", &g_define_type_info, 0);
		g_once_init_leave (&valadate_runner_reader_type_id__volatile, valadate_runner_reader_type_id);
	}
	return valadate_runner_reader_type_id__volatile;
}


GQuark valadate_runner_runner_error_quark (void) {
	return g_quark_from_static_string ("valadate_runner_runner_error-quark");
}


void valadate_runner_process_file (const gchar* file, GError** error) {
	GSList* reader = NULL;
	const gchar* _tmp10_ = NULL;
	GError* _tmp11_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (file != NULL);
	{
		GSList* _tmp0_ = NULL;
		gboolean _tmp1_ = FALSE;
		_tmp0_ = valadate_runner_readers;
		reader = _tmp0_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GSList* _tmp4_ = NULL;
			gboolean _tmp5_ = FALSE;
			GSList* _tmp6_ = NULL;
			gconstpointer _tmp7_ = NULL;
			const gchar* _tmp8_ = NULL;
			gboolean _tmp9_ = FALSE;
			if (!_tmp1_) {
				GSList* _tmp2_ = NULL;
				GSList* _tmp3_ = NULL;
				_tmp2_ = reader;
				_tmp3_ = _tmp2_->next;
				reader = _tmp3_;
			}
			_tmp1_ = FALSE;
			_tmp4_ = reader;
			if (!(_tmp4_ != NULL)) {
				break;
			}
			_tmp6_ = reader;
			_tmp7_ = _tmp6_->data;
			_tmp8_ = file;
			_tmp9_ = valadate_runner_reader_process_file ((ValadateRunnerReader*) _tmp7_, _tmp8_, &_inner_error_);
			_tmp5_ = _tmp9_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				g_propagate_error (error, _inner_error_);
				return;
			}
			if (_tmp5_) {
				return;
			}
		}
	}
	_tmp10_ = file;
	_tmp11_ = g_error_new (VALADATE_RUNNER_RUNNER_ERROR, VALADATE_RUNNER_RUNNER_ERROR_UNRECOGNIZED_FILE, "File %s is not of any known type.", _tmp10_);
	_inner_error_ = _tmp11_;
	g_propagate_error (error, _inner_error_);
	return;
}


void valadate_runner_gather_tests (GError** error) {
	GSList* reader = NULL;
	GError * _inner_error_ = NULL;
	{
		GSList* _tmp0_ = NULL;
		gboolean _tmp1_ = FALSE;
		_tmp0_ = valadate_runner_readers;
		reader = _tmp0_;
		_tmp1_ = TRUE;
		while (TRUE) {
			GSList* _tmp4_ = NULL;
			GSList* _tmp5_ = NULL;
			gconstpointer _tmp6_ = NULL;
			if (!_tmp1_) {
				GSList* _tmp2_ = NULL;
				GSList* _tmp3_ = NULL;
				_tmp2_ = reader;
				_tmp3_ = _tmp2_->next;
				reader = _tmp3_;
			}
			_tmp1_ = FALSE;
			_tmp4_ = reader;
			if (!(_tmp4_ != NULL)) {
				break;
			}
			_tmp5_ = reader;
			_tmp6_ = _tmp5_->data;
			valadate_runner_reader_gather_tests ((ValadateRunnerReader*) _tmp6_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				g_propagate_error (error, _inner_error_);
				return;
			}
		}
	}
}


gint valadate_runner_main (gchar** args, int args_length1) {
	gint result = 0;
	GOptionContext* op = NULL;
	GOptionContext* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = g_option_context_new ("");
	op = _tmp0_;
	{
		GOptionContext* _tmp1_ = NULL;
		GOptionContext* _tmp2_ = NULL;
		GOptionContext* _tmp3_ = NULL;
		GOptionContext* _tmp4_ = NULL;
		GOptionContext* _tmp5_ = NULL;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		ValadateRunnerGirReader* _tmp8_ = NULL;
		ValadateRunnerVapiReader* _tmp9_ = NULL;
		ValadateRunnerVapiReader* _tmp10_ = NULL;
		ValadateRunnerVapiReader* _tmp11_ = NULL;
		gchar** _tmp12_ = NULL;
		gint _tmp12__length1 = 0;
		_tmp1_ = op;
		g_option_context_add_main_entries (_tmp1_, VALADATE_RUNNER_options, NULL);
		_tmp2_ = op;
		g_option_context_set_help_enabled (_tmp2_, TRUE);
		_tmp3_ = op;
		g_option_context_set_description (_tmp3_, "Test Options:\n" "  -l                             List test cases available in a test e" \
"xecutable\n" "  -seed=RANDOMSEED               Provide a random seed to reproduce te" \
"st\n" "                                 runs using random numbers\n" "  --verbose                      Run tests verbosely\n" "  -q, --quiet                    Run tests quietly\n" "  -p TESTPATH                    execute all tests matching TESTPATH\n" "  -m {perf|slow|thorough|quick}  Execute tests according modes\n" "  --debug-log                    debug test logging output\n" "  -k, --keep-going               gtester-specific argument\n" "  --GTestLogFD=N                 gtester-specific argument\n" "  --GTestSkipCount=N             gtester-specific argument\n");
		_tmp4_ = op;
		g_option_context_set_ignore_unknown_options (_tmp4_, TRUE);
		_tmp5_ = op;
		g_option_context_parse (_tmp5_, &args_length1, &args, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp6_ = valadate_runner_files;
		_tmp6__length1 = _vala_array_length (valadate_runner_files);
		if (_tmp6__length1 == 0) {
			FILE* _tmp7_ = NULL;
			_tmp7_ = stderr;
			fprintf (_tmp7_, "Error: No files specified.\n");
			result = 1;
			_g_option_context_free0 (op);
			return result;
		}
		_tmp8_ = valadate_runner_gir_reader_new ();
		valadate_runner_readers = g_slist_prepend (valadate_runner_readers, (ValadateRunnerReader*) _tmp8_);
		_tmp10_ = valadate_runner_vapi_reader_new (&_inner_error_);
		_tmp9_ = _tmp10_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp11_ = _tmp9_;
		_tmp9_ = NULL;
		valadate_runner_readers = g_slist_prepend (valadate_runner_readers, (ValadateRunnerReader*) _tmp11_);
		_tmp12_ = valadate_runner_files;
		_tmp12__length1 = _vala_array_length (valadate_runner_files);
		{
			gchar** file_collection = NULL;
			gint file_collection_length1 = 0;
			gint _file_collection_size_ = 0;
			gint file_it = 0;
			file_collection = _tmp12_;
			file_collection_length1 = _tmp12__length1;
			for (file_it = 0; file_it < _tmp12__length1; file_it = file_it + 1) {
				const gchar* file = NULL;
				file = file_collection[file_it];
				{
					const gchar* _tmp13_ = NULL;
					_tmp13_ = file;
					valadate_runner_process_file (_tmp13_, &_inner_error_);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_object_unref0 (_tmp9_);
						goto __catch0_g_error;
					}
				}
			}
		}
		valadate_runner_gather_tests (&_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (_tmp9_);
			goto __catch0_g_error;
		}
		g_test_init (&args_length1, &args, NULL);
		g_test_run ();
		_g_object_unref0 (_tmp9_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp14_ = NULL;
		GError* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp14_ = stderr;
		_tmp15_ = e;
		_tmp16_ = _tmp15_->message;
		fprintf (_tmp14_, "%s\n", _tmp16_);
		result = 1;
		_g_error_free0 (e);
		_g_option_context_free0 (op);
		return result;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_option_context_free0 (op);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	result = 0;
	_g_option_context_free0 (op);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return valadate_runner_main (argv, argc);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




/* gobject-2.0.vapi generated by vapigen, do not modify. */

[CCode (cprefix = "GI", lower_case_cprefix = "g_")]
namespace GIRepository {
	[CCode (cname = "GIRepository", cheader_filename = "girepository.h")]
	public class IRepository : GLib.Object {
		public weak GLib.Object parent;
		public static bool dump (string arg) throws GLib.Error;
		public GIRepository.BaseInfo find_by_gtype (GLib.Type gtype);
		public GIRepository.BaseInfo find_by_name (string namespace_, string name);
		public unowned string get_c_prefix (string namespace_);
		public static unowned GIRepository.IRepository get_default ();
		public string[] get_dependencies (string namespace_);
		public GIRepository.BaseInfo get_info (string namespace_, int index);
		public string[] get_loaded_namespaces ();
		public int get_n_infos (string namespace_);
		public static GLib.OptionGroup get_option_group ();
		public static unowned GLib.SList get_search_path ();
		public unowned string get_shared_library (string namespace_);
		public unowned string get_typelib_path (string namespace_);
		public unowned string get_version (string namespace_);
		public bool is_registered (string namespace_, string? version);
		public unowned string load_typelib (GIRepository.Typelib typelib, GIRepository.IRepositoryLoadFlags flags) throws GLib.Error;
		public static void prepend_search_path (string directory);
		public GIRepository.Typelib require (string namespace_, string? version, GIRepository.IRepositoryLoadFlags flags) throws GLib.Error;
	}
	[CCode (cname = "GArgument", type_id = "G_TYPE_ARGUMENT", cheader_filename = "girepository.h")]
	public class Argument {
		public bool v_boolean;
		public int8 v_int8;
		public uint8 v_uint8;
		public int16 v_int16;
		public uint16 v_uint16;
		public int32 v_int32;
		public uint32 v_uint32;
		public int64 v_int64;
		public uint64 v_uint64;
		public float v_float;
		public double v_double;
		public short v_short;
		public ushort v_ushort;
		public int v_int;
		public uint v_uint;
		public long v_long;
		public ulong v_ulong;
		public ssize_t v_ssize;
		public size_t v_size;
		public weak string v_string;
		public void* v_pointer;
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class ArgInfo : BaseInfo {
		public int get_closure ();
		public int get_destroy ();
		public GIRepository.Direction get_direction ();
		public GIRepository.Transfer get_ownership_transfer ();
		public GIRepository.ScopeType get_scope ();
		public GIRepository.TypeInfo get_type (); //owned
		public bool is_dipper ();
		public bool is_optional ();
		public bool is_return_value ();
		public bool may_be_null ();
	}
	[CCode (type_id = "G_TYPE_IATTRIBUTE_ITER", cheader_filename = "girepository.h")]
	public struct AttributeIter {
		public void* data;
		public void* data2;
		public void* data3;
		public void* data4;
	}
	[Compact]
	[CCode (ref_function = "g_base_info_ref", unref_function = "g_base_info_unref", cheader_filename = "girepository.h")]
	public class BaseInfo {
		public unowned string get_attribute (string name);
		public unowned GIRepository.BaseInfo get_container ();
		public unowned string get_name ();
		public unowned string get_namespace ();
		public unowned GIRepository.InfoType get_type ();
		public unowned GIRepository.Typelib get_typelib ();
		public bool is_deprecated ();
		public bool iterate_attributes (GIRepository.AttributeIter iterator, [CCode (array_length = false)] string[] name, [CCode (array_length = false)] string[] value);
		//public GIRepository.BaseInfo ref ();
		//public void unref ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class CallableInfo : BaseInfo {
		public GIRepository.ArgInfo get_arg (int n); // owned
		public GIRepository.Transfer get_caller_owns ();
		public int get_n_args ();
		public GIRepository.TypeInfo get_return_type (); // owned
		public bool may_return_null ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class CallbackInfo : CallableInfo {
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class ConstantInfo : BaseInfo {
		public GIRepository.TypeInfo get_type ();
		public int get_value (GIRepository.Argument value); // owned
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class EnumInfo : RegisteredTypeInfo {
		public int get_n_values ();
		public GIRepository.TypeTag get_storage_type ();
		public GIRepository.ValueInfo get_value (int n); // owned
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class ErrorDomainInfo : BaseInfo {
		public GIRepository.InterfaceInfo get_codes (); // owned
		public unowned string get_quark ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class FieldInfo : BaseInfo {
		public bool get_field (void* mem, GIRepository.Argument value);
		public GIRepository.FieldInfoFlags get_flags ();
		public int get_offset ();
		public int get_size ();
		public GIRepository.TypeInfo get_type (); // owned
		public bool set_field (void* mem, GIRepository.Argument value);
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class FunctionInfo : CallableInfo {
		public GIRepository.FunctionInfoFlags get_flags ();
		public GIRepository.PropertyInfo get_property (); // owned
		public unowned string get_symbol ();
		public GIRepository.VFuncInfo get_vfunc ();
		public bool invoke (GIRepository.Argument in_args, int n_in_args, GIRepository.Argument out_args, int n_out_args, GIRepository.Argument return_value) throws GLib.Error;
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class InterfaceInfo : RegisteredTypeInfo {
		public GIRepository.FunctionInfo find_method (string name); // owned
		public GIRepository.VFuncInfo find_vfunc (string name); // owned
		public GIRepository.ConstantInfo get_constant (int n); // owned
		public GIRepository.StructInfo get_iface_struct (); // owned
		public GIRepository.FunctionInfo get_method (int n); // owned
		public int get_n_constants ();
		public int get_n_methods ();
		public int get_n_prerequisites ();
		public int get_n_properties ();
		public int get_n_signals ();
		public int get_n_vfuncs ();
		public GIRepository.BaseInfo get_prerequisite (int n); // owned
		public GIRepository.PropertyInfo get_property (int n); // owned
		public GIRepository.SignalInfo get_signal (int n); // owned
		public GIRepository.VFuncInfo get_vfunc (int n); // owned
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class ObjectInfo : RegisteredTypeInfo {
		public GIRepository.FunctionInfo find_method (string name);
		public GIRepository.VFuncInfo find_vfunc (string name);
		public bool get_abstract ();
		public GIRepository.StructInfo get_class_struct ();
		public GIRepository.ConstantInfo get_constant (int n);
		public GIRepository.FieldInfo get_field (int n);
		public GIRepository.InterfaceInfo get_interface (int n);
		public GIRepository.FunctionInfo get_method (int n);
		public int get_n_constants ();
		public int get_n_fields ();
		public int get_n_interfaces ();
		public int get_n_methods ();
		public int get_n_properties ();
		public int get_n_signals ();
		public int get_n_vfuncs ();
		public GIRepository.ObjectInfo get_parent ();
		public GIRepository.PropertyInfo get_property (int n);
		public GIRepository.SignalInfo get_signal (int n);
		public unowned string get_type_init ();
		public unowned string get_type_name ();
		public GIRepository.VFuncInfo get_vfunc (int n);
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class PropertyInfo : BaseInfo {
		public GLib.ParamFlags get_flags ();
		public GIRepository.TypeInfo get_type ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class RegisteredTypeInfo : BaseInfo {
		public GLib.Type get_g_type ();
		public unowned string get_type_init ();
		public unowned string get_type_name ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class SignalInfo : CallableInfo {
		public GIRepository.VFuncInfo get_class_closure ();
		public GLib.SignalFlags get_flags ();
		public bool true_stops_emit ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class StructInfo : RegisteredTypeInfo {
		public GIRepository.FunctionInfo find_method (string name);
		public size_t get_alignment ();
		public GIRepository.FieldInfo get_field (int n);
		public GIRepository.FunctionInfo get_method (int n);
		public int get_n_fields ();
		public int get_n_methods ();
		public size_t get_size ();
		public bool is_gtype_struct ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class TypeInfo : BaseInfo {
		public int get_array_fixed_size ();
		public int get_array_length ();
		public GIRepository.ErrorDomainInfo get_error_domain (int n);
		public GIRepository.BaseInfo get_interface ();
		public int get_n_error_domains ();
		public GIRepository.TypeInfo get_param_type (int n);
		[CCode (cname = "g_type_info_get_tag")]
		public GIRepository.TypeTag get_tag ();
		public bool is_pointer ();
		public bool is_zero_terminated ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class UnionInfo : RegisteredTypeInfo {
		public GIRepository.FunctionInfo find_method (string name);
		public size_t get_alignment ();
		public GIRepository.ConstantInfo get_discriminator (int n);
		public int get_discriminator_offset ();
		public GIRepository.TypeInfo get_discriminator_type ();
		public GIRepository.FieldInfo get_field (int n);
		public GIRepository.FunctionInfo get_method (int n);
		public int get_n_fields ();
		public int get_n_methods ();
		public size_t get_size ();
		public bool is_discriminated ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class UnresolvedInfo {
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class VFuncInfo : CallableInfo {
		public GIRepository.VFuncInfoFlags get_flags ();
		public GIRepository.FunctionInfo get_invoker ();
		public int get_offset ();
		public GIRepository.SignalInfo get_signal ();
	}
	[Compact]
	[CCode (cheader_filename = "girepository.h")]
	public class ValueInfo : BaseInfo {
		public long get_value ();
	}
	[Compact]
	[CCode (cname = "GTypelib", type_id = "G_TYPE_TYPELIB", cheader_filename = "girepository.h", free_function = "g_typelib_free")]
	public class Typelib {
		public unowned string get_namespace ();
		public bool symbol (string symbol_name, void* symbol);
	}
	[CCode (cprefix = "GI_DIRECTION_", cheader_filename = "girepository.h")]
	public enum Direction {
		IN,
		OUT,
		INOUT
	}
	[CCode (cprefix = "G_IFIELD_INFO_FLAGS_", cheader_filename = "girepository.h")]
	public enum FieldInfoFlags {
		[CCode (cname = "GI_FIELD_IS_READABLE")]
		READABLE,
		[CCode (cname = "GI_FIELD_IS_WRITABLE")]
		WRITABLE
	}
	[CCode (cprefix = "G_IFUNCTION_INFO_FLAGS_", cheader_filename = "girepository.h")]
	public enum FunctionInfoFlags {
		[CCode (cname = "GI_FUNCTION_IS_METHOD")]
		IS_METHOD,
		[CCode (cname = "GI_FUNCTION_IS_CONSTRUCTOR")]
		IS_CONSTRUCTOR,
		[CCode (cname = "GI_FUNCTION_IS_GETTER")]
		IS_GETTER,
		[CCode (cname = "GI_FUNCTION_IS_SETTER")]
		IS_SETTER,
		[CCode (cname = "GI_FUNCTION_WRAPS_VFUNC")]
		WRAPS_VFUNC,
		[CCode (cname = "GI_FUNCTION_THROWS")]
		THROWS
	}
	[CCode (cprefix = "GI_INFO_TYPE_", cheader_filename = "girepository.h")]
	public enum InfoType {
		INVALID,
		FUNCTION,
		CALLBACK,
		STRUCT,
		BOXED,
		ENUM,
		FLAGS,
		OBJECT,
		INTERFACE,
		CONSTANT,
		ERROR_DOMAIN,
		UNION,
		VALUE,
		SIGNAL,
		VFUNC,
		PROPERTY,
		FIELD,
		ARG,
		TYPE,
		UNRESOLVED
	}
	[CCode (cname = "GIRepositoryError", cprefix = "G_IREPOSITORY_ERROR_", cheader_filename = "girepository.h")]
	public enum IRepositoryError {
		TYPELIB_NOT_FOUND,
		NAMESPACE_MISMATCH,
		NAMESPACE_VERSION_CONFLICT,
		LIBRARY_NOT_FOUND
	}
	[CCode (cname = "GIRepositoryLoadFlags", cprefix = "G_IREPOSITORY_LOAD_FLAGS_", cheader_filename = "girepository.h")]
	public enum IRepositoryLoadFlags {
		[CCode (cname = "G_IREPOSITORY_LOAD_FLAG_LAZY")]
		IREPOSITORY_LOAD_FLAG_LAZY
	}
	[CCode (cprefix = "GI_SCOPE_TYPE_", cheader_filename = "girepository.h")]
	public enum ScopeType {
		INVALID,
		CALL,
		ASYNC,
		NOTIFIED
	}
	[CCode (cprefix = "GI_TRANSFER_", cheader_filename = "girepository.h")]
	public enum Transfer {
		NOTHING,
		CONTAINER,
		EVERYTHING
	}
	[CCode (cprefix = "GI_TYPE_TAG_", cheader_filename = "girepository.h")]
	public enum TypeTag {
		VOID,
		BOOLEAN,
		INT8,
		UINT8,
		INT16,
		UINT16,
		INT32,
		UINT32,
		INT64,
		UINT64,
		SHORT,
		USHORT,
		INT,
		UINT,
		LONG,
		ULONG,
		SSIZE,
		SIZE,
		FLOAT,
		DOUBLE,
		TIME_T,
		GTYPE,
		UTF8,
		FILENAME,
		ARRAY,
		INTERFACE,
		GLIST,
		GSLIST,
		GHASH,
		ERROR
	}
	[CCode (cprefix = "G_IV_FUNC_INFO_FLAGS_", cheader_filename = "girepository.h")]
	public enum VFuncInfoFlags {
		[CCode (cname = "GI_VFUNC_MUST_CHAIN_UP")]
		CHAIN_UP,
		[CCode (cname = "GI_VFUNC_MUST_OVERRIDE")]
		OVERRIDE,
		[CCode (cname = "GI_VFUNC_MUST_NOT_OVERRIDE")]
		NOT_OVERRIDE
	}
	[CCode (cprefix = "G_INVOKE_ERROR_", cheader_filename = "girepository.h")]
	public enum nvokeError {
		FAILED,
		SYMBOL_NOT_FOUND,
		ARGUMENT_MISMATCH
	}
	[CCode (cheader_filename = "girepository.h")]
	public static void gi_cclosure_marshal_generic (GLib.Closure closure, GLib.Value return_gvalue, uint n_param_values, GLib.Value param_values, void* invocation_hint, void* marshal_data);
	[CCode (cheader_filename = "girepository.h")]
	public static GIRepository.BaseInfo info_new (GIRepository.InfoType type, GIRepository.BaseInfo container, GIRepository.Typelib typelib, uint32 offset);
	[CCode (cheader_filename = "girepository.h")]
	public static unowned string type_tag_to_string (GIRepository.TypeTag type);
}
